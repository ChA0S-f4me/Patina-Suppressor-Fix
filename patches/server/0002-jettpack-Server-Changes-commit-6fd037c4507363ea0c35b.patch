From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: foss-mc <69294560+foss-mc@users.noreply.github.com>
Date: Tue, 22 Feb 2022 11:55:37 -0800
Subject: [PATCH] jettpack Server Changes commit
 6fd037c4507363ea0c35b4cb9727a1b2c33242b9

mcdev fixes

lithium HashedList

Original code by JellySquid, licensed under GNU Lesser General Public License v3.0
you can find the original code on https://github.com/CaffeineMC/lithium-fabric/ (Yarn mappings)

JettPack Config

(Yatopia) New nbt cache

The goal of this patch is to reduce I/O operations from the main thread while saving player data and also to avoid too many I/O operations while reading NBT Player file by using a cache (Which start to delete the oldest data when there is too much player compared to the map size)

Original code by Yatopia, licensed under MIT License
Co-authored-by: ishland <ishlandmc@yeah.net>

configurable logging of player login location

configurable fishing rod length

(PaperPR) Optimize despawn when no player is on range

Original PR: https://github.com/PaperMC/Paper/pull/7049

Optimize VarInts

Original PR: https://github.com/PaperMC/Paper/pull/6957

lithium: replace AI goal set with optimized collection

Original code licensed under GNU Lesser General Public License v3.0 and created for the lithium project: https://github.com/CaffeineMC/lithium-fabric/

lithium: math.fast_util

Original code licensed under GNU Lesser General Public License v3.0 and created for the lithium project: https://github.com/CaffeineMC/lithium-fabric/

lithium: entity.fast_retrieval

Original code licensed under GNU Lesser General Public License v3.0 and created for the lithium project: https://github.com/CaffeineMC/lithium-fabric/

lithium: cached_hashcode

Original code licensed under GNU Lesser General Public License v3.0 and created for the lithium project: https://github.com/CaffeineMC/lithium-fabric/

lithium: shapes.precompute_shape_arrays

Original code licensed under GNU Lesser General Public License v3.0 and created for the lithium project: https://github.com/CaffeineMC/lithium-fabric/

(PaperPR) Add Alternate Current redstone implementation

Co-authored by: Simon Gardling <titaniumtown@gmail.com>

Originally created by SpaceWalkerRS for the alternate-current (<https://github.com/SpaceWalkerRS/alternate-current>) project and licensed under the MIT license.

This patch implements SpaceWalkerRS's optimized redstone algorithm as an alternative to Eigencraft and Vanilla's implementations. This patch also sets Eigencraft as the default redstone implementation

lithium: entity.fast_powder_snow_check

Original code licensed under GNU Lesser General Public License v3.0 and created for the lithium project: https://github.com/CaffeineMC/lithium-fabric/

lithium: entity.fast_hand_swing

Original code licensed under GNU Lesser General Public License v3.0 and created for the lithium project: https://github.com/CaffeineMC/lithium-fabric/

lithium: collections.entity_by_type

Original code licensed under GNU Lesser General Public License v3.0 and created for the lithium project: https://github.com/CaffeineMC/lithium-fabric/

lithium: collections.entity_filtering

Original code licensed under GNU Lesser General Public License v3.0 and created for the lithium project: https://github.com/CaffeineMC/lithium-fabric/

C2ME: Math optimizations

Original code created for the C2ME project (https://github.com/RelativityMC/C2ME-fabric) by RelativityMC, licensed under the MIT License
Copyright (c) 2021-2022 ishland

lithium: world.inline_height

Original code licensed under GNU Lesser General Public License v3.0 and created for the lithium project: https://github.com/CaffeineMC/lithium-fabric/

lithium: ai.raid

Original code licensed under GNU Lesser General Public License v3.0 and created for the lithium project: https://github.com/CaffeineMC/lithium-fabric/

diff --git a/src/main/java/alternate/current/redstone/Node.java b/src/main/java/alternate/current/redstone/Node.java
new file mode 100644
index 0000000000000000000000000000000000000000..28af1c501da4c7fbfa943a008b5450d16b757423
--- /dev/null
+++ b/src/main/java/alternate/current/redstone/Node.java
@@ -0,0 +1,98 @@
+package alternate.current.redstone;
+
+import java.util.Arrays;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.block.state.BlockState;
+import alternate.current.redstone.WireHandler.Directions;
+
+/**
+ * A Node represents a block in the world. It is tied to a
+ * specific wire block type so it can be identified as part of
+ * a wire network or as a neighbor of a wire network. It also
+ * holds a few other pieces of information that speed up the
+ * calculations in the WireHandler class.
+ * 
+ * @author Space Walker
+ */
+public class Node {
+	
+	// flags that encode the Node type
+	private static final int CONDUCTOR = 0b01;
+	private static final int REDSTONE  = 0b10;
+	
+	public final WireBlock wireBlock;
+	public final WorldAccess world;
+	public final Node[] neighbors;
+	
+	public BlockPos pos;
+	public BlockState state;
+	public boolean invalid;
+	
+	private int flags;
+	
+	public Node(WireBlock wireBlock, WorldAccess world) {
+		this.wireBlock = wireBlock;
+		this.world = world;
+		this.neighbors = new Node[Directions.ALL.length];
+	}
+	
+	@Override
+	public boolean equals(Object o) {
+		if (o instanceof Node) {
+			Node node = (Node)o;
+			return world == node.world && pos.equals(node.pos);
+		}
+		
+		return false;
+	}
+	
+	@Override
+	public int hashCode() {
+		return pos.hashCode();
+	}
+	
+	public Node update(BlockPos pos, BlockState state, boolean clearNeighbors) {
+		if (wireBlock.isOf(state)) {
+			throw new IllegalStateException("Cannot update a regular Node to a WireNode!");
+		}
+		
+		if (clearNeighbors) {
+			Arrays.fill(neighbors, null);
+		}
+		
+		this.pos = pos.immutable();
+		this.state = state;
+		this.invalid = false;
+		
+		this.flags = 0;
+		
+		if (this.world.isConductor(this.pos, this.state)) {
+			this.flags |= CONDUCTOR;
+		}
+		if (this.state.isSignalSource()) {
+			this.flags |= REDSTONE;
+		}
+		
+		return this;
+	}
+	
+	public boolean isOf(WireBlock wireBlock) {
+		return this.wireBlock == wireBlock;
+	}
+	
+	public boolean isWire() {
+		return false;
+	}
+	
+	public boolean isConductor() {
+		return (flags & CONDUCTOR) != 0;
+	}
+	
+	public boolean isRedstoneComponent() {
+		return (flags & REDSTONE) != 0;
+	}
+	
+	public WireNode asWire() {
+		throw new UnsupportedOperationException("Not a WireNode!");
+	}
+}
diff --git a/src/main/java/alternate/current/redstone/PowerQueue.java b/src/main/java/alternate/current/redstone/PowerQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..070973f35bbb07b974f638754547b821143b4c6b
--- /dev/null
+++ b/src/main/java/alternate/current/redstone/PowerQueue.java
@@ -0,0 +1,91 @@
+package alternate.current.redstone;
+
+import java.util.AbstractQueue;
+import java.util.Iterator;
+import java.util.Queue;
+
+import alternate.current.util.collection.SimpleQueue;
+
+public class PowerQueue extends AbstractQueue<WireNode> {
+	
+	private final int minPower;
+	private final int maxPower;
+	private final Queue<WireNode>[] queues;
+	
+	private int size;
+	private int currentQueue;
+	
+	public PowerQueue(int minPower, int maxPower) {
+		this.minPower = minPower;
+		this.maxPower = maxPower;
+		this.queues = createQueues(this.maxPower - this.minPower + 1);
+	}
+	
+	private static Queue<WireNode>[] createQueues(int queueCount) {
+		@SuppressWarnings("unchecked")
+		Queue<WireNode>[] queues = new Queue[queueCount];
+		
+		for (int index = 0; index < queueCount; index++) {
+			queues[index] = new SimpleQueue<>();
+		}
+		
+		return queues;
+	}
+	
+	@Override
+	public boolean offer(WireNode wire) {
+		int queueIndex = wire.nextPower() - minPower;
+		queues[queueIndex].offer(wire);
+		size++;
+		
+		if (queueIndex > currentQueue) {
+			currentQueue = queueIndex;
+		}
+		
+		return true;
+	}
+	
+	@Override
+	public WireNode poll() {
+		if (size == 0) {
+			return null;
+		}
+		
+		WireNode wire;
+		
+		do {
+			wire = queues[currentQueue].poll();
+		} while (wire == null && currentQueue-- > 0);
+		
+		if (wire != null) {
+			size--;
+		}
+		
+		return wire;
+	}
+	
+	@Override
+	public WireNode peek() {
+		if (size == 0) {
+			return null;
+		}
+		
+		WireNode wire;
+		
+		do {
+			wire = queues[currentQueue].peek();
+		} while (wire == null && currentQueue-- > 0);
+		
+		return wire;
+	}
+	
+	@Override
+	public Iterator<WireNode> iterator() {
+		throw new UnsupportedOperationException();
+	}
+	
+	@Override
+	public int size() {
+		return size;
+	}
+}
diff --git a/src/main/java/alternate/current/redstone/WireBlock.java b/src/main/java/alternate/current/redstone/WireBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b3ba9325717a4bd9399537fd15746ae2fc731b2
--- /dev/null
+++ b/src/main/java/alternate/current/redstone/WireBlock.java
@@ -0,0 +1,64 @@
+package alternate.current.redstone;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.util.Mth;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+
+/**
+ * This interface should be implemented by each wire block type.
+ * While Vanilla only has one wire block type, they could add
+ * more in the future, and any mods that add more wire block
+ * types that wish to take advantage of Alternate Current's
+ * performance improvements should have those wire blocks
+ * implement this interface.
+ * 
+ * @author Space Walker
+ */
+public interface WireBlock {
+	
+	public default Block asBlock() {
+		return (Block)this;
+	}
+	
+	public default boolean isOf(BlockState state) {
+		return asBlock() == state.getBlock();
+	}
+	
+	/**
+	 * The lowest possible power level a wire can have.
+	 */
+	public int getMinPower();
+	
+	/**
+	 * The largest possible power level a wire can have.
+	 */
+	public int getMaxPower();
+	
+	/**
+	 * The drop in power level from one wire to the next.
+	 */
+	public int getPowerStep();
+	
+	default int clampPower(int power) {
+		return Mth.clamp(power, getMinPower(), getMaxPower());
+	}
+	
+	/**
+	 * Return the power level of the given wire based on its
+	 * location and block state.
+	 */
+	public int getPower(WorldAccess world, BlockPos pos, BlockState state);
+	
+	/**
+	 * Return a block state that holds the given new power level.
+	 */
+	public BlockState updatePowerState(WorldAccess world, BlockPos pos, BlockState state, int power);
+	
+	/**
+	 * Find the connections between the given WireNode and
+	 * neighboring WireNodes.
+	 */
+	public void findWireConnections(WireNode wire, WireHandler.NodeProvider nodeProvider);
+	
+}
diff --git a/src/main/java/alternate/current/redstone/WireConnection.java b/src/main/java/alternate/current/redstone/WireConnection.java
new file mode 100644
index 0000000000000000000000000000000000000000..fccf3d6b86fd4948c2f7dd7ef30a5f8d407f7444
--- /dev/null
+++ b/src/main/java/alternate/current/redstone/WireConnection.java
@@ -0,0 +1,28 @@
+package alternate.current.redstone;
+
+/**
+ * This class represents a connection between some WireNode (the
+ * 'owner') and a neighboring WireNode. Two wires are considered
+ * to be connected if power can flow from one wire to the other
+ * (and/or vice versa).
+ * 
+ * @author Space Walker
+ */
+public class WireConnection {
+	
+	/** Position of the connected wire. */
+	public final WireNode wire;
+	/** Cardinal direction to the connected wire. */
+	public final int iDir;
+	/** True if the connected wire can provide power to the owner of the connection. */
+	public final boolean in;
+	/** True if the connected wire can accept power from the owner of the connection. */
+	public final boolean out;
+	
+	public WireConnection(WireNode wire, int iDir, boolean in, boolean out) {
+		this.wire = wire;
+		this.iDir = iDir;
+		this.in = in;
+		this.out = out;
+	}
+}
diff --git a/src/main/java/alternate/current/redstone/WireConnectionManager.java b/src/main/java/alternate/current/redstone/WireConnectionManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..4db24a54d1e5c577755a966e88651014192fb454
--- /dev/null
+++ b/src/main/java/alternate/current/redstone/WireConnectionManager.java
@@ -0,0 +1,123 @@
+package alternate.current.redstone;
+
+import java.util.Arrays;
+import java.util.function.BiConsumer;
+
+import alternate.current.redstone.WireHandler.Directions;
+
+public class WireConnectionManager {
+	
+	/**
+	 * The number of bits allocated to store the start indices
+	 * of connections in any cardinal direction.
+	 */
+	private static final int BITS = 4;
+	private static final int MASK = (1 << BITS) - 1;
+	
+	/** The owner of these connections. */
+	public final WireNode wire;
+	
+	/** All connections to other wires. */
+	public WireConnection[] all;
+	
+	/** The total number of connections. */
+	public int count;
+	/** The number of connections per cardinal direction. */
+	private int indices;
+	
+	/**
+	 * A 4 bit number that encodes which in direction(s) the owner
+	 * has connections to other wires.
+	 */
+	private int flowTotal;
+	/** The direction of flow  based connections to other wires. */
+	public int flow;
+	
+	public WireConnectionManager(WireNode wire) {
+		this.wire = wire;
+		this.all = new WireConnection[Directions.HORIZONTAL.length];
+		
+		this.count = 0;
+		this.indices = 0;
+		
+		this.flowTotal = 0;
+		this.flow = -1;
+	}
+	
+	public void set(BiConsumer<ConnectionConsumer, Integer> setter) {
+		if (count > 0) {
+			clear();
+		}
+		
+		for (int iDir = 0; iDir < Directions.HORIZONTAL.length; iDir++) {
+			setIndex(iDir, count);
+			setter.accept(this::add, iDir);
+		}
+		
+		setIndex(Directions.HORIZONTAL.length, count);
+	}
+	
+	private void clear() {
+		Arrays.fill(all, null);
+		
+		count = 0;
+		indices = 0;
+		
+		flowTotal = 0;
+		flow = -1;
+	}
+	
+	private void add(WireNode wire, int iDir, boolean in, boolean out) {
+		addConnection(new WireConnection(wire, iDir, in, out));
+	}
+	
+	private void addConnection(WireConnection connection) {
+		if (count == all.length) {
+			all = doubleSize(all);
+		}
+		
+		all[count++] = connection;
+		
+		flowTotal |= (1 << connection.iDir);
+		flow = WireHandler.FLOW_IN_TO_FLOW_OUT[flowTotal];
+	}
+	
+	/**
+	 * Retrieve the start index of all connections in the given direction.
+	 */
+	public int start(int iDir) {
+		return getIndex(iDir);
+	}
+	
+	/**
+	 * Retrieve the end index of all connections in the given direction.
+	 */
+	public int end(int iDir) {
+		return getIndex(iDir + 1);
+	}
+	
+	private void setIndex(int i, int index) {
+		indices |= (index & MASK) << (i * BITS);
+	}
+	
+	private int getIndex(int i) {
+		return (indices >> (i * BITS)) & MASK;
+	}
+	
+	private static WireConnection[] doubleSize(WireConnection[] array) {
+		WireConnection[] newArray = new WireConnection[array.length << 1];
+		
+		for (int index = 0; index < array.length; index++) {
+			newArray[index] = array[index];
+		}
+		
+		return newArray;
+	}
+	
+	@FunctionalInterface
+	public interface ConnectionConsumer {
+		
+		public void add(WireNode wire, int iDir, boolean in, boolean out);
+		
+	}
+}
diff --git a/src/main/java/alternate/current/redstone/WireHandler.java b/src/main/java/alternate/current/redstone/WireHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f71f1d511d8078d8efce9732e48154f99c8ff2e
--- /dev/null
+++ b/src/main/java/alternate/current/redstone/WireHandler.java
@@ -0,0 +1,1158 @@
+package alternate.current.redstone;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Queue;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.level.block.state.BlockState;
+//import alternate.current.AlternateCurrentMod;
+import alternate.current.util.BlockUtil;
+//import alternate.current.util.profiler.Profiler;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+
+/**
+ * This class handles power changes for redstone wire. The algorithm
+ * was designed with the following goals in mind:
+ * <br>
+ * 1. Minimize the number of times a wire checks its surroundings to
+ *    determine its power level.
+ * <br>
+ * 2. Minimize the number of block and shape updates emitted.
+ * <br>
+ * 3. Emit block and shape updates in a deterministic, non-locational
+ *    order, fixing bug MC-11193.
+ * 
+ * <p>
+ * In Vanilla redstone wire is laggy because it fails on points 1 and 2.
+ * 
+ * <p>
+ * Redstone wire updates recursively and each wire calculates its power
+ * level in isolation rather than in the context of the network it is a
+ * part of. This means a wire in a grid can change its power level over
+ * half a dozen times before settling on its final value. This problem
+ * used to be worse in 1.14 and below, where a wire would only decrease
+ * its power level by 1 at a time.
+ * 
+ * <p>
+ * In addition to this, a wire emits 42 block updates and up to 22 shape
+ * updates each time it changes its power level.
+ * 
+ * <p>
+ * Of those 42 block updates, 6 are to itself, which are thus not only
+ * redundant, but a big source of lag, since those cause the wire to
+ * unnecessarily re-calculate its power level. A block only has 24 
+ * neighbors within a Manhattan distance of 2, meaning 12 of the remaining
+ * 36 block updates are duplicates and thus also redundant.
+ * 
+ * <p>
+ * Of the 22 shape updates, only 6 are strictly necessary. The other 16
+ * are sent to blocks diagonally above and below. These are necessary
+ * if a wire changes its connections, but not when it changes its power
+ * level.
+ * 
+ * <p>
+ * Redstone wire in Vanilla also fails on point 3, though this is more of
+ * a quality-of-life issue than a lag issue. The recursive nature in which
+ * it updates, combined with the location-dependent order in which each
+ * wire updates its neighbors, makes the order in which neighbors of a
+ * wire network are updated incredibly inconsistent and seemingly random.
+ * 
+ * <p>
+ * Alternate Current fixes each of these problems as follows.
+ * 
+ * <p>
+ * 1.
+ * To make sure a wire calculates its power level as little as possible,
+ * we remove the recursive nature in which redstone wire updates in
+ * Vanilla. Instead, we build a network of connected wires, find those
+ * wires that receive redstone power from "outside" the network, and
+ * spread the power from there. This has a few advantages:
+ * <br>
+ * - Each wire checks for power from non-wire components just once, and
+ *   from nearby wires just twice.
+ * <br>
+ * - Each wire only sets its power level in the world once. This is
+ *   important, because calls to World.setBlockState are even more
+ *   expensive than calls to World.getBlockState.
+ * 
+ * <p>
+ * 2.
+ * There are 2 obvious ways in which we can reduce the number of block
+ * and shape updates.
+ * <br>
+ * - Get rid of the 18 redundant block updates and 16 redundant shape
+ *   updates, so each wire only emits 24 block updates and 6 shape updates
+ *   whenever it changes its power level.
+ * <br>
+ * - Only emit block updates and shape updates once a wire reaches its
+ *   final power level, rather than at each intermediary stage. 
+ * <br>
+ * For an individual wire, these two optimizations are the best you can
+ * do, but for an entire grid, you can do better!
+ * 
+ * <p>
+ * Since we calculate the power of the entire network, sending block and
+ * shape updates to the wires in it is redundant. Removing those updates
+ * can reduce the number of block and shape updates by up to 20%.
+ * 
+ * <p>
+ * 3.
+ * To make the order of block updates to neighbors of a network
+ * deterministic, the first thing we must do is to replace the location-
+ * dependent order in which a wire updates its neighbors. Instead, we
+ * base it on the direction of power flow. This part of the algorithm
+ * was heavily inspired by theosib's 'RedstoneWireTurbo', which you can
+ * read more about in theosib's comment on Mojira
+ * <a href="https://bugs.mojang.com/browse/MC-81098?focusedCommentId=420777&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-420777">here</a>
+ * or by checking out its implementation in carpet mod
+ * <a href="https://github.com/gnembon/fabric-carpet/blob/master/src/main/java/carpet/helpers/RedstoneWireTurbo.java">here</a>.
+ * 
+ * <p>
+ * The idea is to determine the direction of power flow through a wire
+ * based on the power it receives from neighboring wires. For example, if
+ * the only power a wire receives is from a neighboring wire to its west,
+ * it can be said that the direction of power flow through the wire is east. 
+ * 
+ * <p>
+ * We make the order of block updates to neighbors of a wire depend on what
+ * is determined to be the direction of power flow. This not only removes
+ * locationality entirely, it even removes directionality in a large
+ * number of cases. Unlike in 'RedstoneWireTurbo', however, I have decided
+ * to keep a directional element in ambiguous cases, rather than to 
+ * introduce randomness, though this is trivial to change.
+ * 
+ * <p>
+ * While this change fixes the block update order of individual wires,
+ * we must still address the overall block update order of a network. This
+ * turns out to be a simple fix, because of a change we made earlier: we
+ * search through the network for wires that receive power from outside it,
+ * and spread the power from there. If we make each wire transmit its power
+ * to neighboring wires in an order dependent on the direction of power
+ * flow, we end up with a non-locational and largely non-directional wire
+ * update order.
+ * 
+ * @author Space Walker
+ */
+public class WireHandler {
+	
+	public static class Directions {
+		
+		public static final Direction[] ALL        = { Direction.WEST, Direction.NORTH, Direction.EAST, Direction.SOUTH, Direction.DOWN, Direction.UP };
+		public static final Direction[] HORIZONTAL = { Direction.WEST, Direction.NORTH, Direction.EAST, Direction.SOUTH };
+		
+		// Indices for the arrays above.
+		// The cardinal directions are ordered clockwise. This allows
+		// for conversion between relative and absolute directions
+		// ('left' 'right' vs 'east' 'west') with simple arithmetic:
+		// If some Direction index 'iDir' is considered 'forward', then
+		// '(iDir + 1) & 0b11' is 'right', '(iDir + 2) & 0b11' is 'backward', etc.
+		public static final int WEST  = 0;
+		public static final int NORTH = 1;
+		public static final int EAST  = 2;
+		public static final int SOUTH = 3;
+		public static final int DOWN  = 4;
+		public static final int UP    = 5;
+		
+		public static int iOpposite(int iDir) {
+			return iDir ^ (0b10 >>> (iDir >>> 2));
+		}
+		
+		public static final int[][] EXCEPT = {
+			{ NORTH, EAST , SOUTH, DOWN , UP   },
+			{ WEST , EAST , SOUTH, DOWN , UP   },
+			{ WEST , NORTH, SOUTH, DOWN , UP   },
+			{ WEST , NORTH, EAST , DOWN , UP   },
+			{ WEST , NORTH, EAST , SOUTH, UP   },
+			{ WEST , NORTH, EAST , SOUTH, DOWN }
+		};
+	}
+	
+	/**
+	 * This conversion table takes in information about incoming flow, and
+	 * outputs the determined outgoing flow.
+	 * 
+	 * <p>
+	 * The input is a 4 bit number that encodes the incoming flow. Each bit
+	 * represents a cardinal direction, and when it is 'on', there is flow
+	 * in that direction.
+	 * 
+	 * <p>
+	 * The output is a single Direction index, or -1 for ambiguous cases.
+	 * 
+	 * <p>
+	 * The outgoing flow is determined as follows:
+	 * 
+	 * <p>
+	 * If there is just 1 direction of incoming flow, that direction will
+	 * be the direction of outgoing flow.
+	 * 
+	 * <p>
+	 * If there are 2 directions of incoming flow, and these directions are
+	 * not each other's opposites, the direction that is 'more clockwise'
+	 * will be the direction of outgoing flow. More precisely, the
+	 * direction that is 1 clockwise turn from the other is picked.
+	 * 
+	 * <p>
+	 * If there are 3 directions of incoming flow, the two opposing
+	 * directions cancel each other out, and the remaining direction will
+	 * be the direction of outgoing flow.
+	 * 
+	 * <p>
+	 * In all other cases, the flow is completely ambiguous.
+	 */
+	public static final int[] FLOW_IN_TO_FLOW_OUT = {
+		-1, // 0b0000: -                      -> x
+		0 , // 0b0001: west                   -> west
+		1 , // 0b0010: north                  -> north
+		1 , // 0b0011: west/north             -> north
+		2 , // 0b0100: east                   -> east
+		-1, // 0b0101: west/east              -> x
+		2 , // 0b0110: north/east             -> east
+		1 , // 0b0111: west/north/east        -> north
+		3 , // 0b1000: south                  -> south
+		0 , // 0b1001: west/south             -> west
+		-1, // 0b1010: north/south            -> x
+		0 , // 0b1011: west/north/south       -> west
+		3 , // 0b1100: east/south             -> south
+		3 , // 0b1101: west/east/south        -> south
+		2 , // 0b1110: north/east/south       -> east
+		-1, // 0b1111: west/north/east/south  -> x
+	};
+	/**
+	 * Update order of cardinal directions. Given that the index is
+	 * to be considered the direction that is 'forward', the resulting
+	 * update order is { front, back, right, left }.
+	 */
+	private static final int[][] CARDINAL_UPDATE_ORDERS = {
+		{ Directions.WEST , Directions.EAST , Directions.NORTH, Directions.SOUTH },
+		{ Directions.EAST , Directions.NORTH, Directions.SOUTH, Directions.WEST  },
+		{ Directions.NORTH, Directions.SOUTH, Directions.WEST , Directions.EAST  },
+		{ Directions.SOUTH, Directions.WEST , Directions.EAST , Directions.NORTH }
+	};
+	/**
+	 * The default update order of all directions. It is equivalent to
+	 * the order of shape updates in vanilla Minecraft.
+	 */
+	private static final int[] DEFAULT_FULL_UPDATE_ORDER = {
+		Directions.WEST,
+		Directions.EAST,
+		Directions.NORTH,
+		Directions.SOUTH,
+		Directions.DOWN,
+		Directions.UP
+	};
+	
+	/*
+	 * While these fields are not strictly necessary, I opted to add
+	 * them with "future proofing" in mind, and to avoid hard-coding
+	 * certain constants.
+	 * 
+	 * If Vanilla will ever multi-thread the ticking of dimensions,
+	 * there should be only one WireHandler per dimension, in case 
+	 * redstone updates in both dimensions at the same time. There are
+	 * already mods that add multi-threading as well.
+	 * 
+	 * If Vanilla ever adds new redstone wire types that cannot interact
+	 * with each other, there should be one WireHandler for each wire
+	 * type, in case two networks of different types update each other.
+	 */
+	private final WireBlock wireBlock;
+	private final WorldAccess world;
+	private final int minPower;
+	private final int maxPower;
+	private final int powerStep;
+	
+	/** All the wires in the network. */
+	private final List<WireNode> network;
+	/** Map of wires and neighboring blocks. */
+	private final Long2ObjectMap<Node> nodes;
+	/** All the power changes that need to happen. */
+	private final Queue<WireNode> powerChanges;
+	
+	private int rootCount;
+	// Rather than creating new nodes every time a network is updated
+	// we keep a cache of nodes that can be re-used.
+	private Node[] nodeCache;
+	private int nodeCount;
+	
+	private boolean updatingPower;
+	
+	public WireHandler(WireBlock wireBlock, WorldAccess world) {
+		this.wireBlock = wireBlock;
+		this.world = world;
+		this.minPower = this.wireBlock.getMinPower();
+		this.maxPower = this.wireBlock.getMaxPower();
+		this.powerStep = this.wireBlock.getPowerStep();
+		
+		this.network = new ArrayList<>();
+		this.nodes = new Long2ObjectOpenHashMap<>();
+		this.powerChanges = new PowerQueue(this.minPower, this.maxPower);
+		
+		this.nodeCache = new Node[16];
+		this.fillNodeCache(0, 16);
+	}
+	
+	private Node getOrAddNode(BlockPos pos) {
+		return nodes.compute(pos.asLong(), (key, node) -> {
+			if (node == null) {
+				// If there is not yet a node at this position,
+				// retrieve and update one from the cache.
+				return getNextNode(pos);
+			}
+			if (node.invalid) {
+				return revalidateNode(node);
+			}
+			
+			return node;
+		});
+	}
+	
+	/**
+	 * Retrieve the neighbor of a node in the given direction and
+	 * create a link between the two nodes.
+	 */
+	private Node getNeighbor(Node node, int iDir) {
+		Node neighbor = node.neighbors[iDir];
+		
+		if (neighbor == null || neighbor.invalid) {
+			Direction dir = Directions.ALL[iDir];
+			BlockPos pos = node.pos.relative(dir);
+			
+			Node oldNeighbor = neighbor;
+			neighbor = getOrAddNode(pos);
+			
+			if (neighbor != oldNeighbor) {
+				int iOpp = Directions.iOpposite(iDir);
+				
+				node.neighbors[iDir] = neighbor;
+				neighbor.neighbors[iOpp] = node;
+			}
+		}
+		
+		return neighbor;
+	}
+	
+	private Node removeNode(BlockPos pos) {
+		return nodes.remove(pos.asLong());
+	}
+	
+	private Node revalidateNode(Node node) {
+		node.invalid = false;
+		
+		if (node.isWire()) {
+			WireNode wire = node.asWire();
+			
+			wire.prepared = false;
+			wire.inNetwork = false;
+		} else {
+			BlockPos pos = node.pos;
+			BlockState state = world.getBlockState(pos);
+			
+			node.update(pos, state, false);
+		}
+		
+		return node;
+	}
+	
+	/**
+	 * Check the BlockState that occupies the given position. If it is
+	 * a wire, then create a new WireNode. Otherwise, grab the next
+	 * Node from the cache and update it.
+	 */
+	private Node getNextNode(BlockPos pos) {
+		BlockState state = world.getBlockState(pos);
+		
+		if (wireBlock.isOf(state)) {
+			return new WireNode(wireBlock, world, pos, state);
+		}
+		
+		return getNextNode().update(pos, state, true);
+	}
+	
+	/**
+	 * Grab the first unused Node from the cache. If all of the cache
+	 * is already in use, increase it in size first.
+	 */
+	private Node getNextNode() {
+		if (nodeCount == nodeCache.length) {
+			increaseNodeCache();
+		}
+		
+		return nodeCache[nodeCount++];
+	}
+	
+	private void increaseNodeCache() {
+		Node[] oldCache = nodeCache;
+		nodeCache = new Node[oldCache.length << 1];
+		
+		for (int index = 0; index < oldCache.length; index++) {
+			nodeCache[index] = oldCache[index];
+		}
+		
+		fillNodeCache(oldCache.length, nodeCache.length);
+	}
+	
+	private void fillNodeCache(int start, int end) {
+		for (int index = start; index < end; index++) {
+			nodeCache[index] = new Node(wireBlock, world);
+		}
+	}
+	
+	/**
+	 * This method is called whenever a redstone wire receives a block
+	 * update.
+	 */
+	public void onWireUpdated(BlockPos pos) {
+		invalidateNodes();
+		findRoots(pos, true);
+		tryUpdatePower();
+	}
+	
+	/**
+	 * This method is called whenever a redstone wire is placed.
+	 */
+	public void onWireAdded(BlockPos pos) {
+		invalidateNodes();
+		findRoots(pos, false);
+		tryUpdatePower();
+	}
+	
+	/**
+	 * This method is called whenever a redstone wire is broken.
+	 */
+	public void onWireRemoved(BlockPos pos) {
+		Node node = removeNode(pos);
+		WireNode wire;
+		
+		if (node == null || !node.isWire()) {
+			wire = new WireNode(wireBlock, world, pos, wireBlock.asBlock().defaultBlockState());
+		} else {
+			wire = node.asWire();
+			
+			// If this field is set to 'true', the removal of this
+			// wire was part of already ongoing power changes, so
+			// we can exit early here.
+			if (updatingPower && wire.shouldBreak) {
+				return;
+			}
+		}
+		
+		wire.invalid = true;
+		wire.removed = true;
+		
+		invalidateNodes();
+		tryAddRoot(wire);
+		tryUpdatePower();
+	}
+	
+	/**
+	 * The nodes map is a snapshot of the state of the world. It
+	 * becomes invalid when power changes are carried out, since
+	 * the block and shape updates can lead to block changes. If
+	 * these block changes cause the network to be updated again
+	 * every node must be invalidated, and revalidated before it
+	 * is used again. This ensures the power calculations of the
+	 * network are accurate.
+	 */
+	private void invalidateNodes() {
+		if (updatingPower && !nodes.isEmpty()) {
+			Iterator<Entry<Node>> it = Long2ObjectMaps.fastIterator(nodes);
+			
+			while (it.hasNext()) {
+				Entry<Node> entry = it.next();
+				Node node = entry.getValue();
+				
+				node.invalid = true;
+			}
+		}
+	}
+	
+	/**
+	 * Look for wires at and around the given position that are
+	 * in an invalid state and require power changes. These wires
+	 * are called 'roots' because it is only when these wires
+	 * change power level that neighboring wires must adjust as
+	 * well.
+	 * 
+	 * <p>
+	 * While it is strictly only necessary to check the wire at
+	 * the given position, if that wire is part of a network, it
+	 * is beneficial to check its surroundings for other wires
+	 * that require power changes. This is because a network can
+	 * receive power at multiple points. Consider the following
+	 * setup:
+	 * 
+	 * <p>
+	 * (top-down view, W = wire, L = lever, _ = air/other)
+	 * <br> {@code _ _ W _ _ }
+	 * <br> {@code _ W W W _ }
+	 * <br> {@code W W L W W }
+	 * <br> {@code _ W W W _ }
+	 * <br> {@code _ _ W _ _ }
+	 * 
+	 * <p>
+	 * The lever powers four wires in the network at once. If this
+	 * is identified correctly, the entire network can (un)power
+	 * at once. While it is not practical to cover every possible
+	 * situation where a network is (un)powered from multiple
+	 * points at once, checking for common cases like the one
+	 * described above is relatively straight-forward.
+	 * 
+	 * <p>
+	 * While these extra checks can provide significant performance
+	 * gains in some cases, in the majority of cases they will have
+	 * little to no effect, but do require extra code modifications
+	 * to all redstone power emitters. Removing these optimizations
+	 * would limit code modifications to the RedstoneWireBlock and
+	 * ServerWorld classes while leaving the performance mostly 
+	 * intact.
+	 */
+	private void findRoots(BlockPos pos, boolean checkNeighbors) {
+		Node node = getOrAddNode(pos);
+		
+		if (!node.isWire()) {
+			return; // we should never get here
+		}
+		
+		WireNode wire = node.asWire();
+		tryAddRoot(wire);
+		
+		// If the wire at the given position is not in an invalid
+		// state or is not part of a larger network, we can exit
+		// early.
+		if (!checkNeighbors || !wire.inNetwork || wire.connections.count == 0) {
+			return;
+		}
+		
+		for (int iDir : DEFAULT_FULL_UPDATE_ORDER) {
+			Node neighbor = getNeighbor(wire, iDir);
+			
+			if (neighbor.isConductor()) {
+				// Redstone components can power multiple wires through
+				// solid blocks.
+				findRedstoneAround(neighbor, Directions.iOpposite(iDir));
+			} else if (world.emitsWeakPowerTo(neighbor.pos, neighbor.state, Directions.ALL[iDir])) {
+				// Redstone components can also power multiple wires
+				// directly.
+				findRootsAroundRedstone(neighbor, Directions.iOpposite(iDir));
+			}
+		}
+	}
+	
+	/**
+	 * Find redstone components around the given node that can
+	 * strongly power that node, and then search for wires that
+	 * require power changes around those redstone components.
+	 */
+	private void findRedstoneAround(Node node, int except) {
+		for (int iDir : Directions.EXCEPT[except]) {
+			Node neighbor = getNeighbor(node, iDir);
+			
+			if (world.emitsStrongPowerTo(neighbor.pos, neighbor.state, Directions.ALL[iDir])) {
+				findRootsAroundRedstone(neighbor, iDir);
+			}
+		}
+	}
+	
+	/**
+	 * Find wires around the given redstone component that require
+	 * power changes.
+	 */
+	private void findRootsAroundRedstone(Node node, int except) {
+		for (int iDir : Directions.EXCEPT[except]) {
+			// Directions are backwards in Minecraft, so we must check
+			// for power emitted in the opposite direction that we are
+			// interested in.
+			int iOpp = Directions.iOpposite(iDir);
+			Direction opp = Directions.ALL[iOpp];
+			
+			boolean weak = world.emitsWeakPowerTo(node.pos, node.state, opp);
+			boolean strong = world.emitsStrongPowerTo(node.pos, node.state, opp);
+			
+			// If the redstone component does not emit any power in
+			// this direction, move on to the next direction.
+			if (!weak && !strong) {
+				continue;
+			}
+			
+			Node neighbor = getNeighbor(node, iDir);
+			
+			if (weak && neighbor.isWire()) {
+				tryAddRoot(neighbor.asWire());
+			} else if (strong && neighbor.isConductor()) {
+				findRootsAround(neighbor, iOpp);
+			}
+		}
+	}
+	
+	/**
+	 * Look for wires around the given node that require power
+	 * changes.
+	 */
+	private void findRootsAround(Node node, int except) {
+		for (int iDir : Directions.EXCEPT[except]) {
+			Node neighbor = getNeighbor(node, iDir);
+			
+			if (neighbor.isWire()) {
+				tryAddRoot(neighbor.asWire());
+			}
+		}
+	}
+	
+	/**
+	 * Check if the given wire is in an illegal state and needs
+	 * power changes.
+	 */
+	private void tryAddRoot(WireNode wire) {
+		// We only want need to check each wire once
+		if (wire.prepared) {
+			return;
+		}
+		
+		prepareWire(wire);
+		findPower(wire, false);
+		
+		if (needsPowerChange(wire)) {
+			network.add(wire);
+			rootCount++;
+			
+			if (wire.connections.flow >= 0) {
+				wire.flowOut = wire.connections.flow;
+			}
+			
+			wire.inNetwork = true;
+		}
+	}
+	
+	/**
+	 * Before a wire can be added to the network, it must be
+	 * properly prepared. This method
+	 * <br>
+	 * - checks if this wire should break. Rather than break
+	 *   the wire right away, its effects are integrated into
+	 *   the power calculations.
+	 * <br>
+	 * - determines the 'external power' this wire receives
+	 *   (power from non-wire components).
+	 * <br>
+	 * - finds connections this wire has to neighboring wires.
+	 */
+	private void prepareWire(WireNode wire) {
+		// Each wire only needs to be prepared once.
+		if (wire.prepared) {
+			return;
+		}
+		
+		wire.prepared = true;
+		wire.inNetwork = false;
+		
+		if (!wire.removed && !wire.shouldBreak && world.shouldBreak(wire.pos, wire.state)) {
+			wire.shouldBreak = true;
+		}
+		
+		wire.virtualPower = wire.externalPower = (wire.removed || wire.shouldBreak) ? minPower : getExternalPower(wire);
+		wireBlock.findWireConnections(wire, this::getNeighbor);
+	}
+	
+	private int getExternalPower(WireNode wire) {
+		int power = minPower;
+		
+		for (int iDir = 0; iDir < Directions.ALL.length; iDir++) {
+			Node neighbor = getNeighbor(wire, iDir);
+			
+			if (neighbor.isWire()) {
+				continue;
+			}
+			
+			if (neighbor.isConductor()) {
+				power = Math.max(power, getStrongPowerTo(neighbor, Directions.iOpposite(iDir)));
+			}
+			if (neighbor.isRedstoneComponent()) {
+				power = Math.max(power, world.getWeakPowerFrom(neighbor.pos, neighbor.state, Directions.ALL[iDir]));
+			}
+			
+			if (power >= maxPower) {
+				return maxPower;
+			}
+		}
+		
+		return power;
+	}
+	
+	/**
+	 * Determine the strong power the given node receives from
+	 * neighboring redstone components.
+	 */
+	private int getStrongPowerTo(Node node, int except) {
+		int power = minPower;
+		
+		for (int iDir : Directions.EXCEPT[except]) {
+			Node neighbor = getNeighbor(node, iDir);
+			
+			if (neighbor.isRedstoneComponent()) {
+				power = Math.max(power, world.getStrongPowerFrom(neighbor.pos, neighbor.state, Directions.ALL[iDir]));
+				
+				if (power >= maxPower) {
+					return maxPower;
+				}
+			}
+		}
+		
+		return power;
+	}
+	
+	/**
+	 * Determine the power level the given wire receives from the
+	 * blocks around it. Power from non-wire components has
+	 * already been determined, so only power received from other
+	 * wires needs to be checked. There are a few exceptions:
+	 * <br>
+	 * - If the wire is removed or going to break, its power level
+	 *   should always be the minimum value. This is because it
+	 *   (effectively) no longer exists, so cannot provide any
+	 *   power to neighboring wires.
+	 * <br>
+	 * - Power received from neighboring wires will never exceed
+	 *   {@code maxPower - powerStep}, so if the external power
+	 *   is already larger than or equal to that, there is no need
+	 *   to check for power from neighboring wires.
+	 */
+	private void findPower(WireNode wire, boolean ignoreNetwork) {
+		if (wire.removed || wire.shouldBreak || wire.externalPower >= (maxPower - powerStep)) {
+			return;
+		}
+		
+		// The virtual power is reset to the external power, so
+		// the flow information must be reset as well.
+		wire.virtualPower = wire.externalPower;
+		wire.flowIn = 0;
+		
+		findWirePower(wire, ignoreNetwork);
+	}
+	
+	/**
+	 * Determine the power level the given wire receives from
+	 * connected wires.
+	 */
+	private void findWirePower(WireNode wire, boolean ignoreNetwork) {
+		for (int c = 0; c < wire.connections.count; c++) {
+			WireConnection connection = wire.connections.all[c];
+			
+			if (!connection.in) {
+				continue;
+			}
+			
+			WireNode neighbor = connection.wire;
+			
+			if (!ignoreNetwork || !neighbor.inNetwork) {
+				int power = Math.max(minPower, neighbor.virtualPower - powerStep);
+				int iOpp = Directions.iOpposite(connection.iDir);
+				
+				wire.offerPower(power, iOpp);
+			}
+		}
+	}
+	
+	private boolean needsPowerChange(WireNode wire) {
+		return wire.removed || wire.shouldBreak || wire.virtualPower != wire.currentPower;
+	}
+	
+	private void tryUpdatePower() {
+		if (rootCount > 0 ) {
+			updatePower();
+		}
+		if (!updatingPower) {
+			nodeCount = 0;
+			nodes.clear();
+		}
+	}
+	
+	/**
+	 * Propagate power changes through the network and notify
+	 * neighboring blocks of these changes.
+	 * 
+	 * <p>
+	 * Power changes are done in the following 3 steps.
+	 * 
+	 * <p>
+	 * <b>1. Build up the network</b>
+	 * <br>
+	 * Collect all the wires around the roots that need to change
+	 * their power levels.
+	 * 
+	 * <p>
+	 * <b>2. Find powered wires</b>
+	 * <br>
+	 * Find those wires in the network that receive redstone power
+	 * from outside the network. This can come in 2 forms:
+	 * <br>
+	 * - Power from non-wire components (repeaters, torches, etc.).
+	 * <br>
+	 * - Power from wires that are not in the network.
+	 * <br>
+	 * These powered wires will then queue their power changes.
+	 * 
+	 * <p>
+	 * <b>3. Let power flow</b>
+	 * <br>
+	 * Work through the queue of power changes. After each wire's
+	 * power change, emit shape and block updates to neighboring
+	 * blocks, then queue power changes for connected wires.
+	 */
+	private void updatePower() {
+		// The profiler keeps track of how long various parts of the
+		// algorithm take. It is only here for debugging purposes,
+		// and is commented out in production.
+//		Profiler profiler = AlternateCurrentMod.createProfiler();
+//		profiler.start();
+		
+		// Build a network of wires that need power changes. This 
+		// includes the roots as well as any wires that will be
+		// affected by power changes to those roots.
+//		profiler.push("build network");
+		buildNetwork();
+		
+		// Find those wires in the network that receive redstone power
+		// from outside it. Remember that the power changes for those
+		// wires are already queued here!
+//		profiler.swap("find powered wires");
+		findPoweredWires();
+		
+		// Once the powered wires have been found, the network is
+		// no longer needed. In fact, it should be cleared before
+		// block and shape updates are emitted, in case a different
+		// network is updated that needs power changes.
+//		profiler.swap("clear " + rootCount + " roots and network of " + network.size());
+		rootCount = 0;
+		network.clear();
+		
+		// Carry out the power changes and emit shape and block updates.
+//		profiler.swap("let power flow");
+		try {
+			letPowerFlow();
+		} catch (Throwable t) {
+			// If anything goes wrong while carrying out power changes,
+			// this value must be reset to 'false', or the wire handler
+			// will be locked out of carrying out power changes until
+			// the world is reloaded.
+			updatingPower = false;
+			
+			throw t;
+		} finally {
+//			profiler.pop();
+//			profiler.end();
+		}
+	}
+	
+	/**
+	 * Build up a network of wires that need power changes. This
+	 * includes the roots that were already added and any wires
+	 * powered by those roots that will need power changes as a
+	 * result of power changes to the roots.
+	 */
+	private void buildNetwork() {
+		for (int index = 0; index < network.size(); index++) {
+			WireNode wire = network.get(index);
+			
+			// The order in which wires are added to the network
+			// can influence the order in which they update their
+			// power levels.
+			for (int iDir : CARDINAL_UPDATE_ORDERS[wire.flowOut]) {
+				int start = wire.connections.start(iDir);
+				int end = wire.connections.end(iDir);
+				
+				for (int c = start; c < end; c++) {
+					WireConnection connection = wire.connections.all[c];
+					
+					if (!connection.out) {
+						continue;
+					}
+					
+					WireNode neighbor = connection.wire;
+					
+					if (neighbor.inNetwork) {
+						continue;
+					}
+					
+					prepareWire(neighbor);
+					findPower(neighbor, false);
+					
+					if (needsPowerChange(neighbor)) {
+						addToNetwork(neighbor, iDir);
+					}
+				}
+			}
+		}
+	}
+	
+	/**
+	 * Add the given wire to the network and set its outgoing flow
+	 * to some backup value. This avoids directionality in redstone
+	 * grids.
+	 */
+	private void addToNetwork(WireNode wire, int backupFlow) {
+		network.add(wire);
+		
+		wire.inNetwork = true;
+		// Normally the flow is not set until the power level is
+		// updated. However, in networks with multiple power
+		// sources the update order between them depends on which
+		// was discovered first. To make this less prone to
+		// directionality, each wire node is given a 'backup' flow.
+		// For roots, this is the determined flow of their
+		// connections. For non-roots this is the direction from
+		// which they were discovered.
+		wire.flowOut = backupFlow;
+	}
+	
+	/**
+	 * Find those wires in the network that receive power from
+	 * outside it, either from non-wire components or from wires
+	 * that are not in the network, and queue the power changes for
+	 * those wires.
+	 */
+	private void findPoweredWires() {
+		for (int index = 0; index < network.size(); index++) {
+			WireNode wire = network.get(index);
+			findPower(wire, true);
+			
+			if (index < rootCount || wire.removed || wire.shouldBreak || wire.virtualPower > minPower) {
+				queuePowerChange(wire);
+			} else {
+				// Wires that do not receive any power do not queue
+				// power changes until they are offered power from a
+				// neighboring wire. To ensure that they accept any
+				// power from neighboring wires and thus queue their
+				// power changes, their virtual power is set to below
+				// the minimum.
+				wire.virtualPower--;
+			}
+		}
+	}
+	
+	/**
+	 * Queue the power change for the given wire.
+	 */
+	private void queuePowerChange(WireNode wire) {
+		if (needsPowerChange(wire)) {
+			powerChanges.add(wire);
+		} else {
+			findPowerFlow(wire);
+			transmitPower(wire);
+		}
+	}
+	
+	/**
+	 * Use the information of incoming power flow to determine the
+	 * direction of power flow through this wire. If that flow is
+	 * ambiguous, try to use a flow direction based on connections
+	 * to neighboring wires. If that is also ambiguous, use the
+	 * backup value that was set when the wire was prepared.
+	 */
+	private void findPowerFlow(WireNode wire) {
+		int flow = FLOW_IN_TO_FLOW_OUT[wire.flowIn];
+		
+		if (flow >= 0) {
+			wire.flowOut = flow;
+		} else if (wire.connections.flow >= 0) {
+			wire.flowOut = wire.connections.flow;
+		}
+	}
+	
+	/**
+	 * Transmit power from the given wire to neighboring wires.
+	 */
+	private void transmitPower(WireNode wire) {
+		int nextPower = Math.max(minPower, wire.virtualPower - powerStep);
+		
+		for (int iDir : CARDINAL_UPDATE_ORDERS[wire.flowOut]) {
+			int start = wire.connections.start(iDir);
+			int end = wire.connections.end(iDir);
+			
+			for (int c = start; c < end; c++) {
+				WireConnection connection = wire.connections.all[c];
+				
+				if (!connection.out) {
+					continue;
+				}
+				
+				WireNode connectedWire = connection.wire;
+				
+				if (connectedWire.offerPower(nextPower, iDir)) {
+					queuePowerChange(connectedWire);
+				}
+			}
+		}
+	}
+	
+	/**
+	 * Carry out power changes, setting the new power of each wire
+	 * in the world, notifying neighbors of the power change, then
+	 * queueing power changes of neighboring wires.
+	 */
+	private void letPowerFlow() {
+		// If an instantaneous update chain causes updates to another
+		// network (or the same network in another place), new power
+		// changes will be integrated into the already ongoing power
+		// queue, so we can exit early here.
+		if (updatingPower) {
+			return;
+		}
+		
+		updatingPower = true;
+		
+		while (!powerChanges.isEmpty()) {
+			WireNode wire = powerChanges.poll();
+			
+			if (!needsPowerChange(wire)) {
+				continue;
+			}
+			
+			findPowerFlow(wire);
+			
+			if (wire.updateState()) {
+				// If the wire was removed, shape updates have already
+				// been emitted.
+				if (!wire.shouldBreak) {
+					updateNeighborShapes(wire);
+				}
+				
+				updateNeighborBlocks(wire);
+			}
+			
+			transmitPower(wire);
+		}
+		
+		updatingPower = false;
+	}
+	
+	/**
+	 * Emit shape updates around the given wire.
+	 */
+	private void updateNeighborShapes(WireNode wire) {
+		BlockPos wirePos = wire.pos;
+		BlockState wireState = wire.state;
+		
+		for (Direction dir : BlockUtil.DIRECTIONS) {
+			updateNeighborShape(wirePos.relative(dir), dir.getOpposite(), wirePos, wireState);
+		}
+	}
+	
+	private void updateNeighborShape(BlockPos pos, Direction fromDir, BlockPos fromPos, BlockState fromState) {
+		BlockState state = world.getBlockState(pos);
+		
+		// Shape updates to redstone wire are very expensive,
+		// and should never happen as a result of power changes
+		// anyway.
+		if (!state.isAir() && !wireBlock.isOf(state)) {
+			world.updateNeighborShape(pos, state, fromDir, fromPos, fromState);
+		}
+	}
+	
+	/**
+	 * Emit block updates around the given wire. The order in which neighbors
+	 * are updated is determined as follows:
+	 * <br>
+	 * 1. The direction of power flow through the wire is to be considered
+	 *    'forward'. The order in which neighbors are updated depends on their
+	 *    relative positions to the wire.
+	 * <br>
+	 * 2. Each neighbor is identified by the step(s) you must take, starting
+	 *    at the wire, to reach it. Each step is 1 block, thus the position
+	 *    of a neighbor is encoded by the direction(s) of the step(s), e.g.
+	 *    (right), (down), (up, left), etc.
+	 * <br>
+	 * 3. Neighbors are updated in pairs that lie on opposite sides of the wire.
+	 * <br>
+	 * 4. Neighbors are updated in order of their distance from the wire. This
+	 *    means they are updated in 3 groups: direct neighbors are updated
+	 *    first, then diagonal neighbors, and last are the far neighbors that
+	 *    are 2 blocks directly out.
+	 * <br>
+	 * 5. The order within each group is determined using the following basic
+	 *    order: { front, back, right, left, down, up }.
+	 *    This order was chosen because it converts to the following order of
+	 *    absolute directions when west is said to be 'forward':
+	 *    { west, east, north, south, down, up } - this is the order of shape
+	 *    updates.
+	 */
+	private void updateNeighborBlocks(WireNode wire) {
+		int iDir = wire.flowOut;
+		
+		Direction forward   = Directions.HORIZONTAL[ iDir            ];
+		Direction rightward = Directions.HORIZONTAL[(iDir + 1) & 0b11];
+		Direction backward  = Directions.HORIZONTAL[(iDir + 2) & 0b11];
+		Direction leftward  = Directions.HORIZONTAL[(iDir + 3) & 0b11];
+		Direction downward  = Direction.DOWN;
+		Direction upward    = Direction.UP;
+		
+		BlockPos self  = wire.pos;
+		BlockPos front = self.relative(forward);
+		BlockPos right = self.relative(rightward);
+		BlockPos back  = self.relative(backward);
+		BlockPos left  = self.relative(leftward);
+		BlockPos below = self.relative(downward);
+		BlockPos above = self.relative(upward);
+		
+		// direct neighbors (6)
+		updateNeighbor(front, self);
+		updateNeighbor(back, self);
+		updateNeighbor(right, self);
+		updateNeighbor(left, self);
+		updateNeighbor(below, self);
+		updateNeighbor(above, self);
+		
+		// diagonal neighbors (12)
+		updateNeighbor(front.relative(rightward), self);
+		updateNeighbor(back .relative(leftward), self);
+		updateNeighbor(front.relative(leftward), self);
+		updateNeighbor(back .relative(rightward), self);
+		updateNeighbor(front.relative(downward), self);
+		updateNeighbor(back .relative(upward), self);
+		updateNeighbor(front.relative(upward), self);
+		updateNeighbor(back .relative(downward), self);
+		updateNeighbor(right.relative(downward), self);
+		updateNeighbor(left .relative(upward), self);
+		updateNeighbor(right.relative(upward), self);
+		updateNeighbor(left .relative(downward), self);
+		
+		// far neighbors (6)
+		updateNeighbor(front.relative(forward), self);
+		updateNeighbor(back .relative(backward), self);
+		updateNeighbor(right.relative(rightward), self);
+		updateNeighbor(left .relative(leftward), self);
+		updateNeighbor(below.relative(downward), self);
+		updateNeighbor(above.relative(upward), self);
+	}
+	
+	private void updateNeighbor(BlockPos pos, BlockPos fromPos) {
+		BlockState state = world.getBlockState(pos);
+		
+		// While this check makes sure wires in the network are not given
+		// block updates, it also prevents block updates to wires in
+		// neighboring networks. While this should not make a difference
+		// in theory, in practice, it is possible to force a network into
+		// an invalid state without updating it, even if it is relatively
+		// obscure.
+		// While I was willing to make this compromise in return for some
+		// significant performance gains in certain setups, if you are not,
+		// you can add all the positions of the network to a set and filter
+		// out block updates to wires in the network that way.
+		if (!state.isAir() && !wireBlock.isOf(state)) {
+			world.updateNeighborBlock(pos, state, fromPos, wireBlock.asBlock());
+		}
+	}
+	
+	@FunctionalInterface
+	public interface NodeProvider {
+		
+		public Node getNeighbor(Node node, int iDir);
+		
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/alternate/current/redstone/WireNode.java b/src/main/java/alternate/current/redstone/WireNode.java
new file mode 100644
index 0000000000000000000000000000000000000000..ed4f071245ae94d4ced5476ef88def48e9768ca7
--- /dev/null
+++ b/src/main/java/alternate/current/redstone/WireNode.java
@@ -0,0 +1,103 @@
+package alternate.current.redstone;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.block.state.BlockState;
+
+/**
+ * A WireNode is a Node that represents a redstone wire in the world.
+ * It stores all the information about the redstone wire that the
+ * WireHandler needs to calculate power changes.
+ * 
+ * @author Space Walker
+ */
+public class WireNode extends Node {
+	
+	public final WireConnectionManager connections;
+	
+	/** The power level this wire currently holds in the world. */
+	public int currentPower;
+	/**
+	 * While calculating power changes for a network, this field
+	 * is used to keep track of the power level this wire should
+	 * have.
+	 */
+	public int virtualPower;
+	/** The power level received from non-wire components. */
+	public int externalPower;
+	/**
+	 * A 4-bit number that keeps track of the power flow of the
+	 * wires that give this wire its power level.
+	 */
+	public int flowIn;
+	/** The direction of power flow, based on the incoming flow. */
+	public int flowOut;
+	public boolean removed;
+	public boolean shouldBreak;
+	public boolean prepared;
+	public boolean inNetwork;
+	
+	public WireNode(WireBlock wireBlock, WorldAccess world, BlockPos pos, BlockState state) {
+		super(wireBlock, world);
+		
+		this.pos = pos.immutable();
+		this.state = state;
+		
+		this.connections = new WireConnectionManager(this);
+		
+		this.virtualPower = this.currentPower = this.wireBlock.getPower(this.world, this.pos, this.state);
+	}
+	
+	@Override
+	public Node update(BlockPos pos, BlockState state, boolean clearNeighbors) {
+		throw new UnsupportedOperationException("Cannot update a WireNode!");
+	}
+	
+	@Override
+	public boolean isWire() {
+		return true;
+	}
+	
+	@Override
+	public WireNode asWire() {
+		return this;
+	}
+	
+	public int nextPower() {
+		return wireBlock.clampPower(virtualPower);
+	}
+	
+	public boolean offerPower(int power, int iDir) {
+		if (removed || shouldBreak) {
+			return false;
+		}
+		if (power == virtualPower) {
+			flowIn |= (1 << iDir);
+			return false;
+		}
+		if (power > virtualPower) {
+			virtualPower = power;
+			flowIn = (1 << iDir);
+			
+			return true;
+		}
+		
+		return false;
+	}
+	
+	public boolean updateState() {
+		if (removed) {
+			return true;
+		}
+		
+		state = world.getBlockState(pos);
+		
+		if (shouldBreak) {
+			return world.breakBlock(pos, state);
+		}
+		
+		currentPower = wireBlock.clampPower(virtualPower);
+		state = wireBlock.updatePowerState(world, pos, state, currentPower);
+		
+		return world.setWireState(pos, state);
+	}
+}
diff --git a/src/main/java/alternate/current/redstone/WorldAccess.java b/src/main/java/alternate/current/redstone/WorldAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..4f1ac60f3070412f9c9286624f76ad39154e28ec
--- /dev/null
+++ b/src/main/java/alternate/current/redstone/WorldAccess.java
@@ -0,0 +1,139 @@
+package alternate.current.redstone;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.LevelChunkSection;
+
+public class WorldAccess {
+	
+	private final WireBlock wireBlock;
+	private final ServerLevel world;
+	private final WireHandler wireHandler;
+	
+	public WorldAccess(WireBlock wireBlock, ServerLevel world) {
+		this.wireBlock = wireBlock;
+		this.world = world;
+		this.wireHandler = new WireHandler(this.wireBlock, this);
+	}
+	
+	public WireHandler getWireHandler() {
+		return wireHandler;
+	}
+	
+	/**
+	 * A slightly optimized version of World.getBlockState.
+	 */
+	public BlockState getBlockState(BlockPos pos) {
+		int y = pos.getY();
+		
+		if (y < world.getMinBuildHeight() || y >= world.getMaxBuildHeight()) {
+			return Blocks.VOID_AIR.defaultBlockState();
+		}
+		
+		int x = pos.getX();
+		int z = pos.getZ();
+		int index = world.getSectionIndex(y);
+		
+		ChunkAccess chunk = world.getChunk(x >> 4, z >> 4, ChunkStatus.FULL, true);
+		LevelChunkSection section = chunk.getSections()[index];
+		
+		if (section == null) {
+			return Blocks.AIR.defaultBlockState();
+		}
+		
+		return section.getBlockState(x & 15, y & 15, z & 15);
+	}
+	
+	/**
+	 * An optimized version of World.setBlockState. Since this method is
+	 * only used to update redstone wire block states, lighting checks,
+	 * height map updates, and block entity updates are omitted.
+	 */
+	public boolean setWireState(BlockPos pos, BlockState state) {
+		if (!wireBlock.isOf(state)) {
+			return false;
+		}
+		
+		int y = pos.getY();
+		
+		if (y < world.getMinBuildHeight() || y >= world.getMaxBuildHeight()) {
+			return false;
+		}
+		
+		int x = pos.getX();
+		int z = pos.getZ();
+		int index = world.getSectionIndex(y);
+		
+		ChunkAccess chunk = world.getChunk(x >> 4, z >> 4, ChunkStatus.FULL, true);
+		LevelChunkSection section = chunk.getSections()[index];
+		
+		if (section == null) {
+			return false; // we should never get here
+		}
+		
+		BlockState prevState = section.setBlockState(x & 15, y & 15, z & 15, state);
+		
+		if (state == prevState) {
+			return false;
+		}
+		
+		// notify clients of the BlockState change
+		world.getChunkSource().blockChanged(pos);
+		// mark the chunk for saving
+		chunk.setUnsaved(true);
+		
+		return true;
+	}
+	
+	public boolean breakBlock(BlockPos pos, BlockState state) {
+		Block.dropResources(state, world, pos);
+		return world.setBlock(pos, Blocks.AIR.defaultBlockState(), Block.UPDATE_CLIENTS);
+	}
+	
+	public void updateNeighborShape(BlockPos pos, BlockState state, Direction fromDir, BlockPos fromPos, BlockState fromState) {
+		BlockState newState = state.updateShape(fromDir, fromState, world, pos, fromPos);
+		Block.updateOrDestroy(state, newState, world, pos, Block.UPDATE_CLIENTS);
+	}
+	
+	public void updateNeighborBlock(BlockPos pos, BlockPos fromPos, Block fromBlock) {
+		getBlockState(pos).neighborChanged(world, pos, fromBlock, fromPos, false);
+	}
+	
+	public void updateNeighborBlock(BlockPos pos, BlockState state, BlockPos fromPos, Block fromBlock) {
+		state.neighborChanged(world, pos, fromBlock, fromPos, false);
+	}
+	
+	public boolean isConductor(BlockPos pos) {
+		return getBlockState(pos).isRedstoneConductor(world, pos);
+	}
+	
+	public boolean isConductor(BlockPos pos, BlockState state) {
+		return state.isRedstoneConductor(world, pos);
+	}
+	
+	public boolean emitsWeakPowerTo(BlockPos pos, BlockState state, Direction dir) {
+		return state.getBlock().emitsWeakPowerTo(world, pos, state, dir);
+	}
+	
+	public boolean emitsStrongPowerTo(BlockPos pos, BlockState state, Direction dir) {
+		return state.getBlock().emitsStrongPowerTo(world, pos, state, dir);
+	}
+	
+	public int getWeakPowerFrom(BlockPos pos, BlockState state, Direction dir) {
+		return state.getSignal(world, pos, dir);
+	}
+	
+	public int getStrongPowerFrom(BlockPos pos, BlockState state, Direction dir) {
+		return state.getDirectSignal(world, pos, dir);
+	}
+	
+	public boolean shouldBreak(BlockPos pos, BlockState state) {
+		return !state.canSurvive(world, pos);
+	}
+}
diff --git a/src/main/java/alternate/current/util/BlockUtil.java b/src/main/java/alternate/current/util/BlockUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..b605c78c20912794a23cc7dbf07bdff12116b666
--- /dev/null
+++ b/src/main/java/alternate/current/util/BlockUtil.java
@@ -0,0 +1,14 @@
+package alternate.current.util;
+
+import net.minecraft.core.Direction;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+
+public abstract class BlockUtil extends BlockBehaviour {
+	
+	/** Directions in the order in which they are used for emitting shape updates. */
+	public static final Direction[] DIRECTIONS = BlockBehaviour.UPDATE_SHAPE_ORDER;
+	
+	private BlockUtil(Properties settings) {
+		super(settings);
+	}
+}
diff --git a/src/main/java/alternate/current/util/collection/SimpleQueue.java b/src/main/java/alternate/current/util/collection/SimpleQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..6d6c1b81b696187add53e744aaffa54df7193864
--- /dev/null
+++ b/src/main/java/alternate/current/util/collection/SimpleQueue.java
@@ -0,0 +1,105 @@
+package alternate.current.util.collection;
+
+import java.util.AbstractQueue;
+import java.util.Iterator;
+
+public class SimpleQueue<E> extends AbstractQueue<E> {
+	
+	private static final int MINIMUM_CAPACITY = 16;
+	
+	private Object[] queue;
+	private int size;
+	private int head;
+	private int tail;
+	
+	public SimpleQueue() {
+		this(MINIMUM_CAPACITY);
+	}
+	
+	public SimpleQueue(int initialCapacity) {
+		if (initialCapacity <= 0) {
+			throw new IllegalArgumentException("The value of initialCapacity must be greater than 0!");
+		}
+		
+		this.queue = new Object[initialCapacity];
+	}
+	
+	@Override
+	public boolean offer(E e) {
+		if (e == null) {
+            throw new NullPointerException();
+		}
+		
+		if (size == queue.length) {
+			resize(size << 1);
+		}
+		
+		queue[tail] = e;
+		tail = incr(tail);
+		size++;
+		
+		return true;
+	}
+	
+	@Override
+	public E poll() {
+		@SuppressWarnings("unchecked")
+		E e = (E)queue[head];
+		
+		if (e != null) {
+			queue[head] = null;
+			head = incr(head);
+			size--;
+			
+			if (queue.length > MINIMUM_CAPACITY && size == (queue.length >> 2)) {
+				resize(size << 1);
+			}
+		}
+		
+		return e;
+	}
+	
+	@Override
+	public E peek() {
+		@SuppressWarnings("unchecked")
+		E e = (E)queue[head];
+		return e;
+	}
+	
+	@Override
+	public Iterator<E> iterator() {
+		throw new UnsupportedOperationException();
+	}
+	
+	@Override
+	public int size() {
+		return size;
+	}
+	
+	private void resize(int newSize) {
+		Object[] oldQueue = queue;
+		queue = new Object[newSize];
+		
+		int i = 0;
+		
+		if (head < tail) {
+			for (int j = head; j < tail; ) {
+				queue[i++] = oldQueue[j++];
+			}
+		} else {
+			for (int j = head; j < oldQueue.length; ) {
+				queue[i++] = oldQueue[j++];
+			}
+			for (int j = 0; j < tail; ) {
+				queue[i++] = oldQueue[j++];
+			}
+		}
+		
+		head = 0;
+		tail = size;
+	}
+	
+	private int incr(int i) {
+		return ++i < queue.length ? i : 0;
+	}
+}
diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index ad3f0ff353a0448babde334641d1b1ac94779b07..15be778f249a959c327d84f43013dc476813c096 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -77,13 +77,37 @@ public class PaperWorldConfig {
         piglinsGuardChests = getBoolean("piglins-guard-chests", piglinsGuardChests);
     }
 
-    public boolean useEigencraftRedstone = false;
-    private void useEigencraftRedstone() {
-        useEigencraftRedstone = this.getBoolean("use-faster-eigencraft-redstone", false);
-        if (useEigencraftRedstone) {
-            log("Using Eigencraft redstone algorithm by theosib.");
-        } else {
-            log("Using vanilla redstone algorithm.");
+    public enum RedstoneAlgo {
+        VANILLA, EIGENCRAFT, ALTERNATE_CURRENT
+    }
+
+    public RedstoneAlgo redstoneAlgo = RedstoneAlgo.EIGENCRAFT;
+    private void redstoneAlgo() {
+        String redstoneAlgoString = getString("redstone-algo", "eigencraft").toLowerCase().trim();
+        if (PaperConfig.version < 25) {
+            boolean oldUseEigenCraft = getBoolean("use-faster-eigencraft-redstone", false);
+            if (!oldUseEigenCraft) {
+                redstoneAlgoString = "vanilla";
+                set("redstone-algo", "vanilla");
+            }
+        }
+        switch (redstoneAlgoString) {
+            case "vanilla":
+                log("Using vanilla redstone algorithm.");
+                redstoneAlgo = RedstoneAlgo.VANILLA;
+                break;
+            case "eigencraft":
+                log("Using Eigencraft redstone algorithm by theosib.");
+                redstoneAlgo = RedstoneAlgo.EIGENCRAFT;
+                break;
+            case "alternate-current":
+                log("Using Alternate Current redstone algorithm by SpaceWalkerRS.");
+                redstoneAlgo = RedstoneAlgo.ALTERNATE_CURRENT;
+                break;
+            default:
+                logError("Warning: redstone-algo set to an invalid value of " + redstoneAlgoString + " must be one of: vanilla, eigencraft, alternate-current. Defaulting to eigencraft.");
+                redstoneAlgo = RedstoneAlgo.EIGENCRAFT;
+                break;
         }
     }
 
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedList.java b/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedList.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d79932dbd1fc386a94b8d6ea3526934c54c2aad
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedList.java
@@ -0,0 +1,280 @@
+package me.jellysquid.mods.lithium.common.util.collections;
+
+import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ReferenceArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+
+/**
+ * Wraps a {@link List} with a hash table which provides O(1) lookups for {@link Collection#contains(Object)}. The type
+ * contained by this list must use reference-equality semantics.
+ */
+@SuppressWarnings("SuspiciousMethodCalls")
+public class HashedList<T> implements List<T> {
+    private final ReferenceArrayList<T> list;
+    private final Reference2IntOpenHashMap<T> counter;
+
+    public HashedList(List<T> list) {
+        this.list = new ReferenceArrayList<>();
+        this.list.addAll(list);
+
+        this.counter = new Reference2IntOpenHashMap<>();
+        this.counter.defaultReturnValue(0);
+
+        for (T obj : this.list) {
+            this.counter.addTo(obj, 1);
+        }
+    }
+
+    @Override
+    public int size() {
+        return this.list.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.list.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return this.counter.containsKey(o);
+    }
+
+    @Override
+    public Iterator<T> iterator() {
+        return this.listIterator();
+    }
+
+    @Override
+    public Object[] toArray() {
+        return this.list.toArray();
+    }
+
+    @SuppressWarnings("SuspiciousToArrayCall")
+    @Override
+    public <T1> T1[] toArray(T1[] a) {
+        return this.list.toArray(a);
+    }
+
+    @Override
+    public boolean add(T t) {
+        this.trackReferenceAdded(t);
+
+        return this.list.add(t);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        this.trackReferenceRemoved(o);
+
+        return this.list.remove(o);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        for (Object obj : c) {
+            if (!this.counter.containsKey(obj)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends T> c) {
+        for (T obj : c) {
+            this.trackReferenceAdded(obj);
+        }
+
+        return this.list.addAll(c);
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends T> c) {
+        for (T obj : c) {
+            this.trackReferenceAdded(obj);
+        }
+
+        return this.list.addAll(index, c);
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> c) {
+        for (Object obj : c) {
+            this.trackReferenceRemoved(obj);
+        }
+
+        return this.list.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> c) {
+        return this.list.retainAll(c);
+    }
+
+    @Override
+    public void clear() {
+        this.counter.clear();
+        this.list.clear();
+    }
+
+    @Override
+    public T get(int index) {
+        return this.list.get(index);
+    }
+
+    @Override
+    public T set(int index, T element) {
+        T prev = this.list.set(index, element);
+
+        if (prev != element) {
+            if (prev != null) {
+                this.trackReferenceRemoved(prev);
+            }
+
+            this.trackReferenceAdded(element);
+        }
+
+        return prev;
+    }
+
+    @Override
+    public void add(int index, T element) {
+        this.trackReferenceAdded(element);
+
+        this.list.add(index, element);
+    }
+
+    @Override
+    public T remove(int index) {
+        T prev = this.list.remove(index);
+
+        if (prev != null) {
+            this.trackReferenceRemoved(prev);
+        }
+
+        return prev;
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        return this.list.indexOf(o);
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        return this.list.lastIndexOf(o);
+    }
+
+    @Override
+    public ListIterator<T> listIterator() {
+        return this.listIterator(0);
+    }
+
+    @Override
+    public ListIterator<T> listIterator(int index) {
+        return new ListIterator<T>() {
+            private final ListIterator<T> inner = HashedList.this.list.listIterator(index);
+
+            @Override
+            public boolean hasNext() {
+                return this.inner.hasNext();
+            }
+
+            @Override
+            public T next() {
+                return this.inner.next();
+            }
+
+            @Override
+            public boolean hasPrevious() {
+                return this.inner.hasPrevious();
+            }
+
+            @Override
+            public T previous() {
+                return this.inner.previous();
+            }
+
+            @Override
+            public int nextIndex() {
+                return this.inner.nextIndex();
+            }
+
+            @Override
+            public int previousIndex() {
+                return this.inner.previousIndex();
+            }
+
+            @Override
+            public void remove() {
+                int last = this.previousIndex();
+
+                if (last == -1) {
+                    throw new NoSuchElementException();
+                }
+
+                T prev = HashedList.this.get(last);
+
+                if (prev != null) {
+                    HashedList.this.trackReferenceRemoved(prev);
+                }
+
+                this.inner.remove();
+            }
+
+            @Override
+            public void set(T t) {
+                int last = this.previousIndex();
+
+                if (last == -1) {
+                    throw new NoSuchElementException();
+                }
+
+                T prev = HashedList.this.get(last);
+
+                if (prev != t) {
+                    if (prev != null) {
+                        HashedList.this.trackReferenceRemoved(prev);
+                    }
+
+                    HashedList.this.trackReferenceAdded(t);
+                }
+
+                this.inner.remove();
+            }
+
+            @Override
+            public void add(T t) {
+                HashedList.this.trackReferenceAdded(t);
+
+                this.inner.add(t);
+            }
+        };
+    }
+
+    @Override
+    public List<T> subList(int fromIndex, int toIndex) {
+        return this.list.subList(fromIndex, toIndex);
+    }
+
+    private void trackReferenceAdded(T t) {
+        this.counter.addTo(t, 1);
+    }
+
+    @SuppressWarnings("unchecked")
+    private void trackReferenceRemoved(Object o) {
+        if (this.counter.addTo((T) o, -1) <= 1) {
+            this.counter.removeInt(o);
+        }
+    }
+
+    public static <T> HashedList<T> wrapper(List<T> list) {
+        return new HashedList<>(list);
+    }
+}
diff --git a/src/main/java/me/titaniumtown/JettPackConfig.java b/src/main/java/me/titaniumtown/JettPackConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..56e9e776750ad569de0d69a3f96994fc4e64d555
--- /dev/null
+++ b/src/main/java/me/titaniumtown/JettPackConfig.java
@@ -0,0 +1,124 @@
+package me.titaniumtown;
+
+import com.google.common.base.Throwables;
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+import java.util.regex.Pattern;
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+public class JettPackConfig {
+
+    public static File CONFIG_FILE;
+    private static final String HEADER = "This is the main configuration file for JettPack.\n"
+                        + "JettPack does some **experimental** and possibly unstable stuff\n"
+                        + "You've been warned\n";
+    /*========================================================================*/
+    public static YamlConfiguration config;
+    public static int version; // since we're remapping sidestreams' configs we need this public
+    public static boolean verbose; // since we're remapping sidestreams' configs we need this public
+    /*========================================================================*/
+
+    public static void init(File configFile) {
+        CONFIG_FILE = configFile;
+        config = new YamlConfiguration();
+        try {
+            config.load(CONFIG_FILE);
+        } catch (IOException ex) {
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not load jettpack.yml, please correct your syntax errors", ex);
+            throw Throwables.propagate(ex);
+        }
+        config.options().header(HEADER);
+        config.options().copyDefaults(true);
+        verbose = getBoolean("verbose", false);
+
+        version = getInt("config-version", 1);
+        set("config-version", 1);
+        readConfig(JettPackConfig.class, null);
+    }
+
+    protected static void logError(String s) {
+        Bukkit.getLogger().severe(s);
+    }
+
+    protected static void log(String s) {
+        if (verbose) {
+            Bukkit.getLogger().info(s);
+        }
+    }
+
+    static void readConfig(Class<?> clazz, Object instance) {
+        for (Method method : clazz.getDeclaredMethods()) {
+            if (Modifier.isPrivate(method.getModifiers())) {
+                if (method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE) {
+                    try {
+                        method.setAccessible(true);
+                        method.invoke(instance);
+                    } catch (InvocationTargetException ex) {
+                        throw Throwables.propagate(ex.getCause());
+                    } catch (Exception ex) {
+                        Bukkit.getLogger().log(Level.SEVERE, "Error invoking " + method, ex);
+                    }
+                }
+            }
+        }
+
+        try {
+            config.save(CONFIG_FILE);
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not save " + CONFIG_FILE, ex);
+        }
+    }
+
+    private static final Pattern SPACE = Pattern.compile(" ");
+    private static final Pattern NOT_NUMERIC = Pattern.compile("[^-\\d.]");
+
+
+    private static void set(String path, Object val) {
+        config.set(path, val);
+    }
+
+    private static boolean getBoolean(String path, boolean def) {
+        config.addDefault(path, def);
+        return config.getBoolean(path, config.getBoolean(path));
+    }
+
+    private static double getDouble(String path, double def) {
+        config.addDefault(path, def);
+        return config.getDouble(path, config.getDouble(path));
+    }
+
+    private static float getFloat(String path, float def) {
+        return (float) getDouble(path, (double) def);
+    }
+
+    private static int getInt(String path, int def) {
+        config.addDefault(path, def);
+        return config.getInt(path, config.getInt(path));
+    }
+
+    private static <T> List<T> getList(String path, List<T> def) {
+        config.addDefault(path, def);
+        return (List<T>) config.getList(path, config.getList(path));
+    }
+
+    private static String getString(String path, String def) {
+        config.addDefault(path, def);
+        return config.getString(path, config.getString(path));
+    }
+
+    public static boolean logPlayerLoginLoc = true;
+    public static double fishingRodLength = 1024.0D;
+    private static void general() {
+        logPlayerLoginLoc = getBoolean("settings.log-player-login-location", logPlayerLoginLoc);
+        fishingRodLength = getDouble("settings.fishing-rod-length", fishingRodLength);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/titaniumtown/cache/NBTCache.java b/src/main/java/me/titaniumtown/cache/NBTCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..0a2d2349f4e3fbde700c0f80ef89f2917e54d505
--- /dev/null
+++ b/src/main/java/me/titaniumtown/cache/NBTCache.java
@@ -0,0 +1,32 @@
+package me.titaniumtown.cache;
+
+import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenCustomHashMap;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.nbt.CompoundTag;
+
+import java.io.File;
+
+public class NBTCache extends Object2ObjectLinkedOpenCustomHashMap<File, CompoundTag> {
+
+    public NBTCache() {
+        super(100, 0.75F, new Strategy<File>() {
+            @Override
+            public int hashCode(File k) {
+                return k.hashCode();
+            }
+
+            @Override
+            public boolean equals(File k, File k1) {
+                return k.equals(k1);
+            }
+        });
+    }
+
+    @Override
+    public CompoundTag put(File k, CompoundTag v) {
+        if (this.size() > MinecraftServer.getServer().getPlayerCount()) {
+            this.removeLast();
+        }
+        return super.putAndMoveToFirst(k, v);
+    }
+}
diff --git a/src/main/java/net/minecraft/core/Direction.java b/src/main/java/net/minecraft/core/Direction.java
index 6d883db5c04cbcf454952c0f361029ecbfe4f037..b0136e72d7e12f7a2ea6f7e4aacb71095e95ecdc 100644
--- a/src/main/java/net/minecraft/core/Direction.java
+++ b/src/main/java/net/minecraft/core/Direction.java
@@ -41,7 +41,7 @@ public enum Direction implements StringRepresentable {
     private final Direction.Axis axis;
     private final Direction.AxisDirection axisDirection;
     private final Vec3i normal;
-    private static final Direction[] VALUES = values();
+    public static final Direction[] VALUES = values(); // JettPack
     private static final Map<String, Direction> BY_NAME = Arrays.stream(VALUES).collect(Collectors.toMap(Direction::getName, (direction) -> {
         return direction;
     }));
@@ -191,7 +191,7 @@ public enum Direction implements StringRepresentable {
     }
 
     public Direction getOpposite() {
-        return from3DDataValue(this.oppositeIndex);
+        return VALUES[this.oppositeIndex]; // JettPack - lithium: fast_util
     }
 
     public Direction getClockWise(Direction.Axis axis) {
@@ -441,7 +441,7 @@ public enum Direction implements StringRepresentable {
     }
 
     public static Direction getRandom(Random random) {
-        return Util.getRandom(VALUES, random);
+        return VALUES[random.nextInt(VALUES.length)]; // JettPack - lithium: fast_util        
     }
 
     public static Direction getNearest(double x, double y, double z) {
diff --git a/src/main/java/net/minecraft/network/FriendlyByteBuf.java b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
index 896a4237f871d46cf39b0721e909c2cc3b5fc728..e2a0a7fd5afd8cd3467dab049695956c381fb3cd 100644
--- a/src/main/java/net/minecraft/network/FriendlyByteBuf.java
+++ b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
@@ -65,19 +65,22 @@ public class FriendlyByteBuf extends ByteBuf {
     public java.util.Locale adventure$locale; // Paper
     public static final short MAX_STRING_LENGTH = 32767;
     public static final int MAX_COMPONENT_STRING_LENGTH = 262144;
+    // Paper start - Optimize VarInts
+    private static final int[] VARINT_EXACT_BYTE_LENGTHS = new int[33];
+    static {
+        for (int i = 0; i <= 32; ++i) {
+            VARINT_EXACT_BYTE_LENGTHS[i] = (int) Math.ceil((31d - (i - 1)) / 7d);
+        }
+        VARINT_EXACT_BYTE_LENGTHS[32] = 1; // Special case for the number 0.
+    }
+    // Paper end - Optimize VarInts
 
     public FriendlyByteBuf(ByteBuf parent) {
         this.source = parent;
     }
 
     public static int getVarIntSize(int value) {
-        for (int j = 1; j < 5; ++j) {
-            if ((value & -1 << j * 7) == 0) {
-                return j;
-            }
-        }
-
-        return 5;
+        return VARINT_EXACT_BYTE_LENGTHS[Integer.numberOfLeadingZeros(value)]; // Paper - Optimize VarInts
     }
 
     public static int getVarLongSize(long value) {
@@ -420,7 +423,23 @@ public class FriendlyByteBuf extends ByteBuf {
         return new UUID(this.readLong(), this.readLong());
     }
 
+    // Paper start - Optimize VarInts
     public FriendlyByteBuf writeVarInt(int value) {
+        // Peel the one and two byte count cases explicitly as they are the most common VarInt sizes
+        // that the proxy will write, to improve inlining.
+        if ((value & (0xFFFFFFFF << 7)) == 0) {
+            writeByte(value);
+        } else if ((value & (0xFFFFFFFF << 14)) == 0) {
+            int w = (value & 0x7F | 0x80) << 8 | (value >>> 7);
+            writeShort(w);
+        } else {
+            writeVarInt_(value);
+        }
+        return this;
+    }
+
+    public FriendlyByteBuf writeVarInt_(int value) {
+    // Paper end - Optimize VarInts
         while ((value & -128) != 0) {
             this.writeByte(value & 127 | 128);
             value >>>= 7;
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 27e90ca03275a42271bbe97ee1a63a355b098ede..568cc931329dadd416fe93a08ce87c953cd5c3ad 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -238,6 +238,15 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         gg.pufferfish.pufferfish.PufferfishConfig.load(); // Pufferfish
         gg.pufferfish.pufferfish.PufferfishCommand.init(); // Pufferfish
 
+        // Yatopia start
+        try {
+            me.titaniumtown.JettPackConfig.init((java.io.File) options.valueOf("jettpack-settings"));
+        } catch (Exception e) {
+            DedicatedServer.LOGGER.error("Unable to load server configuration", e);
+            return false;
+        }
+        // Yatopia end
+
         this.setPvpAllowed(dedicatedserverproperties.pvp);
         this.setFlightAllowed(dedicatedserverproperties.allowFlight);
         this.setResourcePack(dedicatedserverproperties.resourcePack, this.getPackHash());
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 1b6d32d8720f66908b9f1b872115fcff081f5378..466a957cbfde871917b9e968dae8d1f911ea6785 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -162,9 +162,14 @@ import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
+import alternate.current.redstone.WireBlock; // Paper
+import alternate.current.redstone.WorldAccess; // Paper
+import java.util.Map; // Paper
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
+    private final Map<WireBlock, WorldAccess> access = new java.util.HashMap<>(); // Paper
+
     public static final BlockPos END_SPAWN_POINT = new BlockPos(100, 50, 0);
     private static final int MIN_RAIN_DELAY_TIME = 12000;
     private static final int MAX_RAIN_DELAY_TIME = 180000;
@@ -225,6 +230,12 @@ public class ServerLevel extends Level implements WorldGenLevel {
         return convertable.dimensionType;
     }
 
+    // Paper start - port alternate-current
+    public WorldAccess getAccess(WireBlock wireBlock) {
+		return access.computeIfAbsent(wireBlock, key -> new WorldAccess(wireBlock, this));
+	}
+    // Paper end
+
     // Paper start
     public final boolean areChunksLoadedForMove(AABB axisalignedbb) {
         // copied code from collision methods, so that we can guarantee that they wont load chunks (we don't override
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 02dc93c394d37c9a84aa4a58d80615c403c54fb9..fc535087cb8aeba620927a29fe751484788a1fd6 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -494,7 +494,13 @@ public abstract class PlayerList {
         }
         // Paper end
         // CraftBukkit - Moved from above, added world
-        PlayerList.LOGGER.info("{}[{}] logged in with entity id {} at ([{}]{}, {}, {})", player.getName().getString(), s1, player.getId(), worldserver1.serverLevelData.getLevelName(), player.getX(), player.getY(), player.getZ());
+        // JettPack start -  configurable logging of player login location
+        if (me.titaniumtown.JettPackConfig.logPlayerLoginLoc) {
+            PlayerList.LOGGER.info("{}[{}] logged in with entity id {} at ([{}]{}, {}, {})", player.getName().getString(), s1, player.getId(), worldserver1.serverLevelData.getLevelName(), player.getX(), player.getY(), player.getZ());
+        } else {
+            PlayerList.LOGGER.info("{}[{}] logged in with entity id {}", player.getName().getString(), s1, player.getId());
+        }
+        // JettPack end
     }
 
     public void updateEntireScoreboard(ServerScoreboard scoreboard, ServerPlayer player) {
diff --git a/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java b/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
index da725ee77c9e3fd7d9ee89763792ecd31c773037..a4640d98aac3a03032c9c6188f6031bdfc57581e 100644
--- a/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
+++ b/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
@@ -12,9 +12,10 @@ import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.stream.Collectors;
+import it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap; // JettPack
 
 public class ClassInstanceMultiMap<T> extends AbstractCollection<T> {
-    private final Map<Class<?>, List<T>> byClass = Maps.newHashMap();
+    private final Map<Class<?>, List<T>> byClass = new Reference2ReferenceOpenHashMap<>(); // JettPack - lithium: collections.entity_by_type
     private final Class<T> baseClass;
     private final List<T> allInstances = Lists.newArrayList();
 
@@ -56,15 +57,32 @@ public class ClassInstanceMultiMap<T> extends AbstractCollection<T> {
     }
 
     public <S> Collection<S> find(Class<S> type) {
-        if (!this.baseClass.isAssignableFrom(type)) {
-            throw new IllegalArgumentException("Don't know how to search for " + type);
-        } else {
-            List<? extends T> list = this.byClass.computeIfAbsent(type, (typeClass) -> {
-                return this.allInstances.stream().filter(typeClass::isInstance).collect(Collectors.toList());
-            });
-            return Collections.unmodifiableCollection(list);
+        // JettPack start - lithium: collections.entity_filtering
+       Collection<T> collection = this.byClass.get(type);
+
+        if (collection == null) {
+            collection = this.createAllOfType(type);
         }
+
+        return (Collection<S>) Collections.unmodifiableCollection(collection);
+        // JettPack end
+    }
+
+    // JettPack start - lithium: collections.entity_filtering
+    private <S> Collection<T> createAllOfType(Class<S> type) {
+        List<T> list = new java.util.ArrayList<>();
+
+        for (T allElement : this.allInstances) {
+            if (type.isInstance(allElement)) {
+                list.add(allElement);
+            }
+        }
+
+        this.byClass.put(type, list);
+
+        return list;
     }
+    // JettPack end
 
     @Override
     public Iterator<T> iterator() {
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 6a31e29bce673e698922da3c3ba8fd4d8b0adedb..29f07ff73b0ca68249e4960959143f2903d2717c 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -567,11 +567,11 @@ public abstract class LivingEntity extends Entity {
     }
 
     protected void tryAddFrost() {
-        if (!this.getBlockStateOn().isAir()) {
+        // if (!this.getBlockStateOn().isAir()) { // JettPack - lithium: entity.fast_powder_snow_check
             int i = this.getTicksFrozen();
 
             if (i > 0) {
-                AttributeInstance attributemodifiable = this.getAttribute(Attributes.MOVEMENT_SPEED);
+                AttributeInstance attributemodifiable = this.getBlockStateOn().isAir() ? null : this.getAttribute(Attributes.MOVEMENT_SPEED); // JettPack - lithium: entity.fast_powder_snow_check
 
                 if (attributemodifiable == null) {
                     return;
@@ -581,8 +581,7 @@ public abstract class LivingEntity extends Entity {
 
                 attributemodifiable.addTransientModifier(new AttributeModifier(LivingEntity.SPEED_MODIFIER_POWDER_SNOW_UUID, "Powder snow slow", (double) f, AttributeModifier.Operation.ADDITION));
             }
-        }
-
+        // } // JettPack - lithium: entity.fast_powder_snow_check
     }
 
     protected void onChangedBlock(BlockPos pos) {
@@ -2431,6 +2430,7 @@ public abstract class LivingEntity extends Entity {
     }
 
     protected void updateSwingTime() {
+        if (!this.swinging && this.swingTime == 0) return; // JettPack - lithium: entity.fast_hand_swing
         int i = this.getCurrentSwingDuration();
 
         if (this.swinging) {
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index d7a0fb4727e263932846a67c584da2c8d6d4e275..4fb2cb8745e3dda531cffa7389b0fc9adea972c8 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -796,9 +796,6 @@ public abstract class Mob extends LivingEntity {
         } else if (!this.isPersistenceRequired() && !this.requiresCustomPersistence()) {
             // Paper start - optimise checkDespawn
             Player entityhuman = this.level.findNearbyPlayer(this, level.paperConfig.hardDespawnDistances.getInt(this.getType().getCategory()) + 1, EntitySelector.affectsSpawning); // Paper
-            if (entityhuman == null) {
-                entityhuman = ((ServerLevel)this.level).playersAffectingSpawning.isEmpty() ? null : ((ServerLevel)this.level).playersAffectingSpawning.get(0);
-            }
             // Paper end - optimise checkDespawn
 
             if (entityhuman != null) {
@@ -818,6 +815,8 @@ public abstract class Mob extends LivingEntity {
                 } else if (d0 < (double) l) {
                     this.noActionTime = 0;
                 }
+            } else {
+                this.discard(); // Paper - no entity found on hardDespawnDistance, we should discard it
             }
 
         } else {
diff --git a/src/main/java/net/minecraft/world/entity/ai/Brain.java b/src/main/java/net/minecraft/world/entity/ai/Brain.java
index 32456644dfd2e45dfc02cd1fa77d7afd9e1db1e9..98d810d318724432e45858f00adb467d998e5c19 100644
--- a/src/main/java/net/minecraft/world/entity/ai/Brain.java
+++ b/src/main/java/net/minecraft/world/entity/ai/Brain.java
@@ -73,16 +73,16 @@ public class Brain<E extends LivingEntity> {
             }
 
             public <T> DataResult<Brain<E>> decode(DynamicOps<T> dynamicOps, MapLike<T> mapLike) {
-                MutableObject<DataResult<Builder<Brain.MemoryValue<?>>>> mutableObject = new MutableObject<>(DataResult.success(ImmutableList.builder()));
+                MutableObject<DataResult<Builder<Brain.MemoryValue<?>>>> decode_mutableObject = new MutableObject<>(DataResult.success(ImmutableList.builder())); // JettPack - decomp fix
                 mapLike.entries().forEach((pair) -> {
                     DataResult<MemoryModuleType<?>> dataResult = Registry.MEMORY_MODULE_TYPE.byNameCodec().parse(dynamicOps, pair.getFirst());
                     DataResult<? extends Brain.MemoryValue<?>> dataResult2 = dataResult.flatMap((memoryModuleType) -> {
                         return this.captureRead(memoryModuleType, dynamicOps, (T)pair.getSecond());
                     });
-                    mutableObject.setValue(mutableObject.getValue().apply2(Builder::add, dataResult2));
+                    decode_mutableObject.setValue(decode_mutableObject.getValue().apply2(Builder::add, dataResult2)); // JettPack - decomp fix
                 });
-                ImmutableList<Brain.MemoryValue<?>> immutableList = mutableObject.getValue().resultOrPartial(Brain.LOGGER::error).map(Builder::build).orElseGet(ImmutableList::of);
-                return DataResult.success(new Brain<>(memoryModules, sensors, immutableList, mutableObject::getValue));
+                ImmutableList<Brain.MemoryValue<?>> immutableList = decode_mutableObject.getValue().resultOrPartial(Brain.LOGGER::error).map(Builder::build).orElseGet(ImmutableList::of); // JettPack - decomp fix
+                return DataResult.success(new Brain<E>(memoryModules, sensors, immutableList, mutableObject::getValue)); // JettPack - decomp fix
             }
 
             private <T, U> DataResult<Brain.MemoryValue<U>> captureRead(MemoryModuleType<U> memoryModuleType, DynamicOps<T> dynamicOps, T object) {
@@ -134,7 +134,7 @@ public class Brain<E extends LivingEntity> {
 
     Stream<Brain.MemoryValue<?>> memories() {
         return this.memories.entrySet().stream().map((entry) -> {
-            return Brain.MemoryValue.createUnchecked(entry.getKey(), entry.getValue());
+            return Brain.MemoryValue.createUnchecked((MemoryModuleType)entry.getKey(), (Optional)entry.getValue()); // JettPack - decomp fix
         });
     }
 
@@ -170,7 +170,7 @@ public class Brain<E extends LivingEntity> {
     }
 
     public <U> Optional<U> getMemory(MemoryModuleType<U> type) {
-        return this.memories.get(type).map(ExpirableValue::getValue);
+        return ((Optional)this.memories.get(type)).map(object -> ((ExpirableValue)object).getValue()); // JettPack - decomp fix    
     }
 
     public <U> long getTimeUntilExpiry(MemoryModuleType<U> type) {
@@ -353,7 +353,7 @@ public class Brain<E extends LivingEntity> {
     }
 
     public Brain<E> copyWithoutBehaviors() {
-        Brain<E> brain = new Brain<>(this.memories.keySet(), this.sensors.keySet(), ImmutableList.of(), this.codec);
+        Brain<E> brain = new Brain<E>(this.memories.keySet(), this.sensors. keySet(), ImmutableList.of(), this.codec); // JettPack - decomp fix
 
         for(Entry<MemoryModuleType<?>, Optional<? extends ExpirableValue<?>>> entry : this.memories.entrySet()) {
             MemoryModuleType<?> memoryModuleType = entry.getKey();
@@ -463,8 +463,8 @@ public class Brain<E extends LivingEntity> {
         private final MemoryModuleType<U> type;
         private final Optional<? extends ExpirableValue<U>> value;
 
-        static <U> Brain.MemoryValue<U> createUnchecked(MemoryModuleType<U> type, Optional<? extends ExpirableValue<?>> data) {
-            return new Brain.MemoryValue<>(type, data);
+        static <U> Brain.MemoryValue<U> createUnchecked(MemoryModuleType<U> type, Optional<? extends ExpirableValue<U>> data) { // JettPack - decomp fix
+            return new Brain.MemoryValue<U>(type, data); // JettPack - decomp fix
         }
 
         MemoryValue(MemoryModuleType<U> type, Optional<? extends ExpirableValue<U>> data) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
index 8229001df0a901d9016fb16e4ddc81b5a0f51452..f9fd8d173b8bc42409de98fb163a6119531d1afb 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -13,6 +13,7 @@ import java.util.function.Supplier;
 import java.util.stream.Stream;
 import net.minecraft.util.profiling.ProfilerFiller;
 import org.slf4j.Logger;
+import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet; // JettPack
 
 public class GoalSelector {
     private static final Logger LOGGER = LogUtils.getLogger();
@@ -28,7 +29,7 @@ public class GoalSelector {
         }
     };
     private final Map<Goal.Flag, WrappedGoal> lockedFlags = new EnumMap<>(Goal.Flag.class);
-    public final Set<WrappedGoal> availableGoals = Sets.newLinkedHashSet();
+    public final Set<WrappedGoal> availableGoals = new ObjectLinkedOpenHashSet<>(); // JettPack - lithium: replace AI goal set with optimized collection
     private final Supplier<ProfilerFiller> profiler;
     private final EnumSet<Goal.Flag> disabledFlags = EnumSet.noneOf(Goal.Flag.class); // Paper unused, but dummy to prevent plugins from crashing as hard. Theyll need to support paper in a special case if this is super important, but really doesn't seem like it would be.
     private final com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<net.minecraft.world.entity.ai.goal.Goal.Flag> goalTypes = new com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<>(Goal.Flag.class); // Paper - remove streams from pathfindergoalselector
diff --git a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
index 3789a0db398766f0fbc9e5ac5bf4228a0a0dac88..07810a1da6f8ad310e50d1b2d37b1b67878d4596 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
@@ -146,7 +146,7 @@ public class FishingHook extends Projectile {
 
     @Override
     public boolean shouldRenderAtSqrDistance(double distance) {
-        double d1 = 64.0D;
+        // double d1 = 64.0D; // Jettpack
 
         return distance < 4096.0D;
     }
@@ -251,7 +251,7 @@ public class FishingHook extends Projectile {
                 this.setDeltaMovement(Vec3.ZERO);
             }
 
-            double d1 = 0.92D;
+            // double d1 = 0.92D; // Jettpack
 
             this.setDeltaMovement(this.getDeltaMovement().scale(0.92D));
             this.reapplyPosition();
@@ -264,7 +264,7 @@ public class FishingHook extends Projectile {
         boolean flag = itemstack.is(Items.FISHING_ROD);
         boolean flag1 = itemstack1.is(Items.FISHING_ROD);
 
-        if (!player.isRemoved() && player.isAlive() && (flag || flag1) && this.distanceToSqr((Entity) player) <= 1024.0D) {
+        if (!player.isRemoved() && player.isAlive() && (flag || flag1) && this.distanceToSqr((Entity) player) <= me.titaniumtown.JettPackConfig.fishingRodLength) { // Jettpack
             return false;
         } else {
             this.discard();
diff --git a/src/main/java/net/minecraft/world/entity/raid/Raid.java b/src/main/java/net/minecraft/world/entity/raid/Raid.java
index f50abfd058e3adf1cf8c0f4468a60bc04e8541e7..a078f637ed005dfad5c2c2f601e4ba5964ba7f8d 100644
--- a/src/main/java/net/minecraft/world/entity/raid/Raid.java
+++ b/src/main/java/net/minecraft/world/entity/raid/Raid.java
@@ -269,7 +269,16 @@ public class Raid {
         this.status = Raid.RaidStatus.STOPPED;
     }
 
+    private boolean isBarDirty; // JettPack
     public void tick() {
+        // JettPack start - lithium: ai.raid
+        if (this.isBarDirty) {
+            this.raidEvent.setProgress(Mth.clamp(this.getHealthOfLivingRaiders() / this.totalHealth, 0.0F, 1.0F));
+
+            this.isBarDirty = false;
+        }
+        // JettPack end
+
         if (!this.isStopped()) {
             if (this.status == Raid.RaidStatus.ONGOING) {
                 boolean flag = this.active;
@@ -625,7 +634,7 @@ public class Raid {
     }
 
     public void updateBossbar() {
-        this.raidEvent.setProgress(Mth.clamp(this.getHealthOfLivingRaiders() / this.totalHealth, 0.0F, 1.0F));
+        this.isBarDirty = true; // JettPack - lithium: ai.raid
     }
 
     public float getHealthOfLivingRaiders() {
diff --git a/src/main/java/net/minecraft/world/entity/raid/Raider.java b/src/main/java/net/minecraft/world/entity/raid/Raider.java
index c5611465b1f9228a994c462c093cec94d7d08c2f..dfffbf47b58e16c9b5b750ccdb9717eacf414a64 100644
--- a/src/main/java/net/minecraft/world/entity/raid/Raider.java
+++ b/src/main/java/net/minecraft/world/entity/raid/Raider.java
@@ -46,8 +46,9 @@ import net.minecraft.world.phys.Vec3;
 public abstract class Raider extends PatrollingMonster {
 
     protected static final EntityDataAccessor<Boolean> IS_CELEBRATING = SynchedEntityData.defineId(Raider.class, EntityDataSerializers.BOOLEAN);
+    public static final ItemStack CACHED_OMINOUS_BANNER = Raid.getLeaderBannerInstance(); // JettPack - lithium: ai.raid
     static final Predicate<ItemEntity> ALLOWED_ITEMS = (entityitem) -> {
-        return !entityitem.hasPickUpDelay() && entityitem.isAlive() && ItemStack.matches(entityitem.getItem(), Raid.getLeaderBannerInstance());
+        return !entityitem.hasPickUpDelay() && entityitem.isAlive() && ItemStack.matches(entityitem.getItem(), CACHED_OMINOUS_BANNER); // JettPack - lithium: ai.raid
     };
     @Nullable
     protected Raid raid;
@@ -149,7 +150,7 @@ public abstract class Raider extends PatrollingMonster {
                     }
                 }
 
-                if (!itemstack.isEmpty() && ItemStack.matches(itemstack, Raid.getLeaderBannerInstance()) && entityhuman != null) {
+                if (!itemstack.isEmpty() && ItemStack.matches(itemstack, CACHED_OMINOUS_BANNER) && entityhuman != null) { // JettPack - lithium: ai.raid
                     MobEffectInstance mobeffect = entityhuman.getEffect(MobEffects.BAD_OMEN);
                     byte b0 = 1;
                     int i;
@@ -304,6 +305,7 @@ public abstract class Raider extends PatrollingMonster {
     public class ObtainRaidLeaderBannerGoal<T extends Raider> extends Goal {
 
         private final T mob;
+        private static final ItemStack CACHED_OMINOUS_BANNER = Raid.getLeaderBannerInstance(); // JettPack
 
         public ObtainRaidLeaderBannerGoal(T entityraider) { // CraftBukkit - decompile error
             this.mob = entityraider;
@@ -315,7 +317,7 @@ public abstract class Raider extends PatrollingMonster {
             if (!this.mob.level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING) || !this.mob.canPickUpLoot()) return false; // Paper - respect game and entity rules for picking up items
             Raid raid = this.mob.getCurrentRaid();
 
-            if (this.mob.hasActiveRaid() && !this.mob.getCurrentRaid().isOver() && this.mob.canBeLeader() && !ItemStack.matches(this.mob.getItemBySlot(EquipmentSlot.HEAD), Raid.getLeaderBannerInstance())) {
+            if (this.mob.hasActiveRaid() && !this.mob.getCurrentRaid().isOver() && this.mob.canBeLeader() && !ItemStack.matches(this.mob.getItemBySlot(EquipmentSlot.HEAD), CACHED_OMINOUS_BANNER)) { // JettPack - lithium: ai.raid
                 Raider entityraider = raid.getLeader(this.mob.getWave());
 
                 if (entityraider == null || !entityraider.isAlive()) {
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 8026e8ca528071bf80fecb5e96370d1d2ae799db..ef6ac13300ecff50cac98167bef5a5f747bed250 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -115,8 +115,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public static final int TICKS_PER_DAY = 24000;
     public static final int MAX_ENTITY_SPAWN_Y = 20000000;
     public static final int MIN_ENTITY_SPAWN_Y = -20000000;
-    protected final List<TickingBlockEntity> blockEntityTickers = Lists.newArrayList(); public final int getTotalTileEntityTickers() { return this.blockEntityTickers.size(); } // Paper
-    private final List<TickingBlockEntity> pendingBlockEntityTickers = Lists.newArrayList();
+    protected final List<TickingBlockEntity> blockEntityTickers = me.jellysquid.mods.lithium.common.util.collections.HashedList.wrapper(Lists.newArrayList()); public final int getTotalTileEntityTickers() { return this.blockEntityTickers.size(); } // Paper // Jettpack - lithium: hashed_list
+    private final List<TickingBlockEntity> pendingBlockEntityTickers = me.jellysquid.mods.lithium.common.util.collections.HashedList.wrapper(Lists.newArrayList()); // Jettpack - lithium: hashed_list
     private boolean tickingBlockEntities;
     public final Thread thread;
     private final boolean isDebug;
diff --git a/src/main/java/net/minecraft/world/level/block/BasePressurePlateBlock.java b/src/main/java/net/minecraft/world/level/block/BasePressurePlateBlock.java
index 2036006b934ba1f27da606320b4c456af019a361..c5fa5c6725b8054e2e5b7f0b8bbc679266008f78 100644
--- a/src/main/java/net/minecraft/world/level/block/BasePressurePlateBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/BasePressurePlateBlock.java
@@ -21,6 +21,18 @@ import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
 
 public abstract class BasePressurePlateBlock extends Block {
 
+    // Paper start - port alternate-current
+    @Override
+	public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return true;
+	}
+    
+	@Override
+	public boolean emitsStrongPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return dir == Direction.UP;
+	}
+    // Paper end
+
     protected static final VoxelShape PRESSED_AABB = Block.box(1.0D, 0.0D, 1.0D, 15.0D, 0.5D, 15.0D);
     protected static final VoxelShape AABB = Block.box(1.0D, 0.0D, 1.0D, 15.0D, 1.0D, 15.0D);
     protected static final AABB TOUCH_AABB = new AABB(0.125D, 0.0D, 0.125D, 0.875D, 0.25D, 0.875D);
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index a80f4dc0a642c744223a155232291ace6e007636..87a91a063088dded6b43544777fffa6e56342f31 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -65,6 +65,16 @@ import org.slf4j.Logger;
 
 public class Block extends BlockBehaviour implements ItemLike {
 
+    // Paper start - port Alternate Current
+	public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return false;
+	}
+	
+	public boolean emitsStrongPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return false;
+	}
+    // Paper end
+
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Holder.Reference<Block> builtInRegistryHolder;
     public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY = new IdMapper<>();
@@ -597,11 +607,18 @@ public class Block extends BlockBehaviour implements ItemLike {
         private final BlockState first;
         private final BlockState second;
         private final Direction direction;
+        private int hash; // JettPack
 
         public BlockStatePairKey(BlockState self, BlockState other, Direction facing) {
             this.first = self;
             this.second = other;
             this.direction = facing;
+            // JettPack start - lithium: cached_hashcode
+            int hash = this.first.hashCode();
+            hash = 31 * hash + this.second.hashCode();
+            hash = 31 * hash + this.direction.hashCode();
+            this.hash = hash;
+            // JettPack end
         }
 
         public boolean equals(Object object) {
@@ -617,11 +634,7 @@ public class Block extends BlockBehaviour implements ItemLike {
         }
 
         public int hashCode() {
-            int i = this.first.hashCode();
-
-            i = 31 * i + this.second.hashCode();
-            i = 31 * i + this.direction.hashCode();
-            return i;
+            return this.hash; // JettPack
         }
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/block/ButtonBlock.java b/src/main/java/net/minecraft/world/level/block/ButtonBlock.java
index b7f37475192bf79252482314080c9ba08e9aefdb..7c10e817cacec1fbacbf9d67da941748c6785165 100644
--- a/src/main/java/net/minecraft/world/level/block/ButtonBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/ButtonBlock.java
@@ -33,6 +33,18 @@ import org.bukkit.event.entity.EntityInteractEvent;
 
 public abstract class ButtonBlock extends FaceAttachedHorizontalDirectionalBlock {
 
+    // Paper start - port alternate-current
+    @Override
+    public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return true;
+	}
+	
+    @Override
+	public boolean emitsStrongPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return getConnectedDirection(state) == dir;
+	}
+    // Paper end
+
     public static final BooleanProperty POWERED = BlockStateProperties.POWERED;
     private static final int PRESSED_DEPTH = 1;
     private static final int UNPRESSED_DEPTH = 2;
diff --git a/src/main/java/net/minecraft/world/level/block/DaylightDetectorBlock.java b/src/main/java/net/minecraft/world/level/block/DaylightDetectorBlock.java
index 40b0380aa6fd052bf6376a15939c08e603f2f60c..f2c556ff5556f467c84359ed61afa6a3ab6929a1 100644
--- a/src/main/java/net/minecraft/world/level/block/DaylightDetectorBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/DaylightDetectorBlock.java
@@ -26,6 +26,13 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 
 public class DaylightDetectorBlock extends BaseEntityBlock {
 
+    // Paper start - port alternate-current
+    @Override
+    public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+        return true;
+    }
+    // Paper end
+
     public static final IntegerProperty POWER = BlockStateProperties.POWER;
     public static final BooleanProperty INVERTED = BlockStateProperties.INVERTED;
     protected static final VoxelShape SHAPE = Block.box(0.0D, 0.0D, 0.0D, 16.0D, 6.0D, 16.0D);
diff --git a/src/main/java/net/minecraft/world/level/block/DiodeBlock.java b/src/main/java/net/minecraft/world/level/block/DiodeBlock.java
index 9c764d2273d70b8dffcaa7f324544cb48f12acc3..63adeacd5f05e56cebca89ac2c2fba221dc60607 100644
--- a/src/main/java/net/minecraft/world/level/block/DiodeBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/DiodeBlock.java
@@ -22,6 +22,18 @@ import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
 public abstract class DiodeBlock extends HorizontalDirectionalBlock {
 
+    // Paper start - port alternate-current
+    @Override
+	public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return state.getValue(BlockStateProperties.HORIZONTAL_FACING) == dir;
+	}
+	
+    @Override
+	public boolean emitsStrongPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return state.getValue(BlockStateProperties.HORIZONTAL_FACING) == dir;
+	}
+    // Paper end
+
     protected static final VoxelShape SHAPE = Block.box(0.0D, 0.0D, 0.0D, 16.0D, 2.0D, 16.0D);
     public static final BooleanProperty POWERED = BlockStateProperties.POWERED;
 
diff --git a/src/main/java/net/minecraft/world/level/block/LecternBlock.java b/src/main/java/net/minecraft/world/level/block/LecternBlock.java
index 25ed6dfef2887612a02fcf8884dc8dac4fbd64ff..76f3a8d084593be25b1b16da7f6c961ae524accf 100644
--- a/src/main/java/net/minecraft/world/level/block/LecternBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/LecternBlock.java
@@ -37,6 +37,18 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 
 public class LecternBlock extends BaseEntityBlock {
 
+    // Paper start - port alternate-current
+    @Override
+	public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return true;
+	}
+    
+	@Override
+	public boolean emitsStrongPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return dir == Direction.UP;
+	}
+    // Paper end
+
     public static final DirectionProperty FACING = HorizontalDirectionalBlock.FACING;
     public static final BooleanProperty POWERED = BlockStateProperties.POWERED;
     public static final BooleanProperty HAS_BOOK = BlockStateProperties.HAS_BOOK;
diff --git a/src/main/java/net/minecraft/world/level/block/LeverBlock.java b/src/main/java/net/minecraft/world/level/block/LeverBlock.java
index 1093dc8595e42a90e74e19f74965f5be07a1d6cf..9dd3e28a809c251c54e85f84ff3a292c7825fb70 100644
--- a/src/main/java/net/minecraft/world/level/block/LeverBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/LeverBlock.java
@@ -26,6 +26,18 @@ import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
 
 public class LeverBlock extends FaceAttachedHorizontalDirectionalBlock {
 
+    // Paper start - port alternate-current
+    @Override
+    public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return true;
+	}
+	
+    @Override
+	public boolean emitsStrongPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return getConnectedDirection(state) == dir;
+	}
+    // Paper end
+
     public static final BooleanProperty POWERED = BlockStateProperties.POWERED;
     protected static final int DEPTH = 6;
     protected static final int WIDTH = 6;
diff --git a/src/main/java/net/minecraft/world/level/block/LightningRodBlock.java b/src/main/java/net/minecraft/world/level/block/LightningRodBlock.java
index b7605dda79c4d907f5822a0ded694b080e08dae5..1a98b3fcb250ee6c0ff2de84bb4b3b65b8ca20ce 100644
--- a/src/main/java/net/minecraft/world/level/block/LightningRodBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/LightningRodBlock.java
@@ -38,6 +38,18 @@ import org.bukkit.event.block.BlockRedstoneEvent;
 
 public class LightningRodBlock extends RodBlock implements SimpleWaterloggedBlock {
 
+    // Paper start - port alternate-current
+    @Override
+	public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return true;
+	}
+	
+    @Override
+	public boolean emitsStrongPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return state.getValue(BlockStateProperties.FACING) == dir;
+	}
+    // Paper end
+
     public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;
     public static final BooleanProperty POWERED = BlockStateProperties.POWERED;
     private static final int ACTIVATION_TICKS = 8;
diff --git a/src/main/java/net/minecraft/world/level/block/ObserverBlock.java b/src/main/java/net/minecraft/world/level/block/ObserverBlock.java
index 4a34a08a1d46e4d3020644a51d9e30a36a18791a..7c1871fbf327b9423fd59639db6c1c276bac416b 100644
--- a/src/main/java/net/minecraft/world/level/block/ObserverBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/ObserverBlock.java
@@ -17,6 +17,18 @@ import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
 public class ObserverBlock extends DirectionalBlock {
 
+    // Paper start - port alternate-current
+    @Override
+	public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return state.getValue(BlockStateProperties.FACING) == dir;
+	}
+	
+    @Override
+	public boolean emitsStrongPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return state.getValue(BlockStateProperties.FACING) == dir;
+	}
+    // Paper end
+
     public static final BooleanProperty POWERED = BlockStateProperties.POWERED;
 
     public ObserverBlock(BlockBehaviour.Properties settings) {
diff --git a/src/main/java/net/minecraft/world/level/block/PoweredBlock.java b/src/main/java/net/minecraft/world/level/block/PoweredBlock.java
index 0afffc33f3be221a28c62115f493808aeffb1bd8..eb792a5d16826bbed2c9b4d306b9eed09aeaaa02 100644
--- a/src/main/java/net/minecraft/world/level/block/PoweredBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/PoweredBlock.java
@@ -11,6 +11,13 @@ public class PoweredBlock extends Block {
         super(settings);
     }
 
+    // Paper start - port alternate-current
+    @Override
+    public boolean emitsWeakPowerTo(net.minecraft.world.level.Level world, BlockPos pos, BlockState state, Direction dir) {
+        return true;
+    }
+    // Paper end
+
     @Override
     public boolean isSignalSource(BlockState state) {
         return true;
diff --git a/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java b/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java
index 037330bcb10039c013b2ed5fd68dee16ede20fbe..9e3e65ac4e21a44d4cf563e11453b38f8b68c93d 100644
--- a/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java
@@ -39,8 +39,82 @@ import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
+import com.destroystokyo.paper.PaperWorldConfig; // Paper
+// Paper start
+import alternate.current.redstone.Node;
+import alternate.current.redstone.WireBlock;
+import alternate.current.redstone.WireHandler;
+import alternate.current.redstone.WireNode;
+import alternate.current.redstone.WorldAccess;
+import alternate.current.redstone.WireHandler.NodeProvider;
+import net.minecraft.server.level.ServerLevel;
+// Paper end
+
+public class RedStoneWireBlock extends Block implements WireBlock { // Paper
+
+    // Paper start - port alternate-current
+    @Override
+	public int getMinPower() {
+		return 0;
+	}
+	
+	@Override
+	public int getMaxPower() {
+		return 15;
+	}
+	
+	@Override
+	public int getPowerStep() {
+		return 1;
+    }
+
+	@Override
+	public int getPower(WorldAccess world, BlockPos pos, BlockState state) {
+		return state.getValue(BlockStateProperties.POWER);
+	}
+	
+	@Override
+	public BlockState updatePowerState(WorldAccess world, BlockPos pos, BlockState state, int power) {
+		return state.setValue(BlockStateProperties.POWER, power);
+	}
 
-public class RedStoneWireBlock extends Block {
+    @Override
+    public Block asBlock() {
+		return (Block)this;
+	}
+	
+	@Override
+	public void findWireConnections(WireNode wire, NodeProvider nodes) {
+		boolean belowIsConductor = nodes.getNeighbor(wire, WireHandler.Directions.DOWN).isConductor();
+		boolean aboveIsConductor = nodes.getNeighbor(wire, WireHandler.Directions.UP).isConductor();
+		
+		wire.connections.set((connections, iDir) -> {
+			Node neighbor = nodes.getNeighbor(wire, iDir);
+			
+			if (neighbor.isWire()) {
+				connections.add(neighbor.asWire(), iDir, true, true);
+				return;
+			}
+			
+			boolean sideIsConductor = neighbor.isConductor();
+			
+			if (!sideIsConductor) {
+				Node node = nodes.getNeighbor(neighbor, WireHandler.Directions.DOWN);
+				
+				if (node.isWire()) {
+					connections.add(node.asWire(), iDir, true, belowIsConductor);
+				}
+			}
+			if (!aboveIsConductor) {
+				Node node = nodes.getNeighbor(neighbor, WireHandler.Directions.UP);
+				
+				if (node.isWire()) {
+					connections.add(node.asWire(), iDir, sideIsConductor, true);
+				}
+			}
+		});
+	}
+    // Paper end
 
     public static final EnumProperty<RedstoneSide> NORTH = BlockStateProperties.NORTH_REDSTONE;
     public static final EnumProperty<RedstoneSide> EAST = BlockStateProperties.EAST_REDSTONE;
@@ -267,7 +341,7 @@ public class RedStoneWireBlock extends Block {
      * Note: Added 'source' argument so as to help determine direction of information flow
      */
     private void updateSurroundingRedstone(Level worldIn, BlockPos pos, BlockState state, BlockPos source) {
-        if (worldIn.paperConfig.useEigencraftRedstone) {
+        if (worldIn.paperConfig.redstoneAlgo == PaperWorldConfig.RedstoneAlgo.EIGENCRAFT) {
             turbo.updateSurroundingRedstone(worldIn, pos, state, source);
             return;
         }
@@ -291,7 +365,7 @@ public class RedStoneWireBlock extends Block {
         int k = worldIn.getBestNeighborSignal(pos1);
         this.shouldSignal = true;
 
-        if (!worldIn.paperConfig.useEigencraftRedstone) {
+        if (worldIn.paperConfig.redstoneAlgo != PaperWorldConfig.RedstoneAlgo.EIGENCRAFT) {
             // This code is totally redundant to if statements just below the loop.
             if (k > 0 && k > j - 1) {
                 j = k;
@@ -305,7 +379,7 @@ public class RedStoneWireBlock extends Block {
         // redstone wire will be set to 'k'.  If 'k' is already 15, then nothing inside the
         // following loop can affect the power level of the wire.  Therefore, the loop is
         // skipped if k is already 15.
-        if (!worldIn.paperConfig.useEigencraftRedstone || k < 15) {
+        if (worldIn.paperConfig.redstoneAlgo != PaperWorldConfig.RedstoneAlgo.EIGENCRAFT || k < 15) {
             for (Direction enumfacing : Direction.Plane.HORIZONTAL) {
                 BlockPos blockpos = pos1.relative(enumfacing);
                 boolean flag = blockpos.getX() != pos2.getX() || blockpos.getZ() != pos2.getZ();
@@ -324,7 +398,7 @@ public class RedStoneWireBlock extends Block {
             }
         }
 
-        if (!worldIn.paperConfig.useEigencraftRedstone) {
+        if (worldIn.paperConfig.redstoneAlgo != PaperWorldConfig.RedstoneAlgo.EIGENCRAFT) {
             // The old code would decrement the wire value only by 1 at a time.
             if (l > j) {
                 j = l - 1;
@@ -373,6 +447,7 @@ public class RedStoneWireBlock extends Block {
     // Paper end
 
     private void updatePowerStrength(Level world, BlockPos pos, BlockState state) {
+        if (world.paperConfig.redstoneAlgo == PaperWorldConfig.RedstoneAlgo.ALTERNATE_CURRENT) return; // Paper - port Alternate Current
         int i = this.calculateTargetStrength(world, pos);
 
         // CraftBukkit start
@@ -464,7 +539,19 @@ public class RedStoneWireBlock extends Block {
     @Override
     public void onPlace(BlockState state, Level world, BlockPos pos, BlockState oldState, boolean notify) {
         if (!oldState.is(state.getBlock()) && !world.isClientSide) {
-            this.updateSurroundingRedstone(world, pos, state, null); // Paper - Optimize redstone
+            // Paper start - port Alternate Current
+            if (world.paperConfig.redstoneAlgo == PaperWorldConfig.RedstoneAlgo.ALTERNATE_CURRENT) {
+                ((ServerLevel)world).getAccess(this).getWireHandler().onWireAdded(pos);
+                BlockState newState = world.getBlockState(pos);
+            
+                if (newState != state) {
+                    newState.updateNeighbourShapes(world, pos, Block.UPDATE_CLIENTS);
+                    newState.updateIndirectNeighbourShapes(world, pos, Block.UPDATE_CLIENTS);
+                }
+            } else {
+                this.updateSurroundingRedstone(world, pos, state, null);
+            }
+            // Paper end
             Iterator iterator = Direction.Plane.VERTICAL.iterator();
 
             while (iterator.hasNext()) {
@@ -491,7 +578,13 @@ public class RedStoneWireBlock extends Block {
                     world.updateNeighborsAt(pos.relative(enumdirection), this);
                 }
 
-                this.updateSurroundingRedstone(world, pos, state, null); // Paper - Optimize redstone
+                // Paper start - port Alternate Current
+                if (world.paperConfig.redstoneAlgo == PaperWorldConfig.RedstoneAlgo.ALTERNATE_CURRENT) {
+                    ((ServerLevel)world).getAccess(this).getWireHandler().onWireRemoved(pos); // Paper
+                } else {
+                    this.updateSurroundingRedstone(world, pos, state, null); 
+                }
+                // Paper end
                 this.updateNeighborsOfNeighboringWires(world, pos);
             }
         }
@@ -524,15 +617,18 @@ public class RedStoneWireBlock extends Block {
 
     @Override
     public void neighborChanged(BlockState state, Level world, BlockPos pos, Block block, BlockPos fromPos, boolean notify) {
-        if (!world.isClientSide) {
+        // Paper start - port alternate-current
+        if (world.paperConfig.redstoneAlgo == PaperWorldConfig.RedstoneAlgo.ALTERNATE_CURRENT) {
+            ((ServerLevel)world).getAccess(this).getWireHandler().onWireUpdated(pos);
+        } else {
             if (state.canSurvive(world, pos)) {
                 this.updateSurroundingRedstone(world, pos, state, fromPos); // Paper - Optimize redstone
             } else {
                 dropResources(state, world, pos);
                 world.removeBlock(pos, false);
             }
-
         }
+        // Paper end
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/RedstoneTorchBlock.java b/src/main/java/net/minecraft/world/level/block/RedstoneTorchBlock.java
index 954b86bea345a8e0e3a8dd425f356db6f5cd496f..6b18f1947df9ddc427ec8deb2890592ae61d621c 100644
--- a/src/main/java/net/minecraft/world/level/block/RedstoneTorchBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/RedstoneTorchBlock.java
@@ -20,6 +20,18 @@ import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
 
 public class RedstoneTorchBlock extends TorchBlock {
 
+    // Paper start - port alternate-current
+    @Override
+	public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return dir != Direction.UP;
+	}
+    
+	@Override
+	public boolean emitsStrongPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return dir == Direction.DOWN;
+	}
+    // Paper end
+
     public static final BooleanProperty LIT = BlockStateProperties.LIT;
     // Paper - Move the mapped list to World
     public static final int RECENT_TOGGLE_TIMER = 60;
diff --git a/src/main/java/net/minecraft/world/level/block/RedstoneWallTorchBlock.java b/src/main/java/net/minecraft/world/level/block/RedstoneWallTorchBlock.java
index 5cf0ae04059533385a19f7b07909a67b57350c09..8551e4ef9f42d4114f42daa0f128244c15399d08 100644
--- a/src/main/java/net/minecraft/world/level/block/RedstoneWallTorchBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/RedstoneWallTorchBlock.java
@@ -17,7 +17,17 @@ import net.minecraft.world.level.block.state.properties.DirectionProperty;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
+import net.minecraft.world.level.block.state.properties.BlockStateProperties; // Paper
+
 public class RedstoneWallTorchBlock extends RedstoneTorchBlock {
+
+    // Paper start - port alternate-current
+    @Override
+    public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+        return state.getValue(BlockStateProperties.HORIZONTAL_FACING) != dir;
+    }
+    // Paper end
+
     public static final DirectionProperty FACING = HorizontalDirectionalBlock.FACING;
     public static final BooleanProperty LIT = RedstoneTorchBlock.LIT;
 
diff --git a/src/main/java/net/minecraft/world/level/block/SculkSensorBlock.java b/src/main/java/net/minecraft/world/level/block/SculkSensorBlock.java
index 33bca696c1ae0a63055eea5d2e05551458da50b4..591b99bb2d362d442f7c771446dd48f52e6e6f6c 100644
--- a/src/main/java/net/minecraft/world/level/block/SculkSensorBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/SculkSensorBlock.java
@@ -44,6 +44,13 @@ import org.bukkit.event.block.BlockRedstoneEvent;
 
 public class SculkSensorBlock extends BaseEntityBlock implements SimpleWaterloggedBlock {
 
+    // Paper start - port alternate-current
+    @Override
+    public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+        return true;
+    }
+    // Paper end
+
     public static final int ACTIVE_TICKS = 40;
     public static final int COOLDOWN_TICKS = 1;
     public static final Object2IntMap<GameEvent> VIBRATION_STRENGTH_FOR_EVENT = Object2IntMaps.unmodifiable((Object2IntMap) Util.make(new Object2IntOpenHashMap(), (object2intopenhashmap) -> {
diff --git a/src/main/java/net/minecraft/world/level/block/TargetBlock.java b/src/main/java/net/minecraft/world/level/block/TargetBlock.java
index d609c60c1650a5b7f860154e0a4f4c6d84fa63fc..850b2de7cc961f7b3e460a90297cf6eb4d92a25b 100644
--- a/src/main/java/net/minecraft/world/level/block/TargetBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/TargetBlock.java
@@ -23,6 +23,14 @@ import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
 
 public class TargetBlock extends Block {
+
+    // Paper start - port alternate-current
+    @Override
+    public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+        return true;
+    }
+    // Paper end
+
     private static final IntegerProperty OUTPUT_POWER = BlockStateProperties.POWER;
     private static final int ACTIVATION_TICKS_ARROWS = 20;
     private static final int ACTIVATION_TICKS_OTHER = 8;
diff --git a/src/main/java/net/minecraft/world/level/block/TrappedChestBlock.java b/src/main/java/net/minecraft/world/level/block/TrappedChestBlock.java
index 184c70cd2954f4904518c3fee2a377d9c4e81cc3..ec5b7f28a151539d678e85132f6aeb27cf2f3612 100644
--- a/src/main/java/net/minecraft/world/level/block/TrappedChestBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/TrappedChestBlock.java
@@ -14,7 +14,22 @@ import net.minecraft.world.level.block.entity.TrappedChestBlockEntity;
 import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.block.state.BlockState;
 
+import net.minecraft.world.level.Level; // Paper
+
 public class TrappedChestBlock extends ChestBlock {
+
+    // Paper start - port alternate-current
+    @Override
+	public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return true;
+	}
+    
+	@Override
+	public boolean emitsStrongPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return dir == Direction.UP;
+	}
+    // Paper end
+
     public TrappedChestBlock(BlockBehaviour.Properties settings) {
         super(settings, () -> {
             return BlockEntityType.TRAPPED_CHEST;
diff --git a/src/main/java/net/minecraft/world/level/block/TripWireHookBlock.java b/src/main/java/net/minecraft/world/level/block/TripWireHookBlock.java
index a4344bf2267112e3c1e31c07c9f6b8eae9666947..3b4ef54b11cb98c390ea6b494112dcf450613f08 100644
--- a/src/main/java/net/minecraft/world/level/block/TripWireHookBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/TripWireHookBlock.java
@@ -27,8 +27,22 @@ import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
 
+import net.minecraft.world.level.block.state.properties.BlockStateProperties; // Paper
+
 public class TripWireHookBlock extends Block {
 
+    // Paper start - port alternate-current
+    @Override
+	public boolean emitsWeakPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return true;
+	}
+    
+	@Override
+	public boolean emitsStrongPowerTo(Level world, BlockPos pos, BlockState state, Direction dir) {
+		return state.getValue(BlockStateProperties.HORIZONTAL_FACING) == dir;
+	}
+    // Paper end
+
     public static final DirectionProperty FACING = HorizontalDirectionalBlock.FACING;
     public static final BooleanProperty POWERED = BlockStateProperties.POWERED;
     public static final BooleanProperty ATTACHED = BlockStateProperties.ATTACHED;
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 74882f89f32b14ff8cd44f0e4eb1f350f52d636d..9532296f49b56d5d5ccdcf0d2781026235a0a776 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -76,6 +76,54 @@ public class LevelChunk extends ChunkAccess {
             return "<null>";
         }
     };
+
+    // JettPack start - lithium: world.inline_height
+    @Override
+    public int getMaxBuildHeight() {
+        return this.level.getMaxBuildHeight();
+    }
+
+    @Override
+    public int getSectionsCount() {
+        return this.level.getSectionsCount();
+    }
+
+    @Override
+    public int getMinSection() {
+        return this.level.getMinSection();
+    }
+
+    @Override
+    public int getMaxSection() {
+        return this.level.getMaxSection();
+    }
+
+    @Override
+    public boolean isOutsideBuildHeight(BlockPos pos) {
+        return this.level.isOutsideBuildHeight(pos);
+    }
+
+    @Override
+    public boolean isOutsideBuildHeight(int y) {
+        return this.level.isOutsideBuildHeight(y);
+    }
+
+    @Override
+    public int getSectionIndex(int y) {
+        return this.level.getSectionIndex(y);
+    }
+
+    @Override
+    public int getSectionIndexFromSectionY(int coord) {
+        return this.level.getSectionIndexFromSectionY(coord);
+    }
+
+    @Override
+    public int getSectionYFromSectionIndex(int index) {
+        return this.level.getSectionYFromSectionIndex(index);
+    }
+    // JettPack end
+
     private final Map<BlockPos, LevelChunk.RebindableTickingBlockEntityWrapper> tickersInLevel;
     public boolean loaded;
     private boolean clientLightReady;
diff --git a/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java b/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
index 74210dc2eef63da7360b1f833bb59b278419fb2b..859d2e82f21efa1232e7e69f787840b16ed4bd4b 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
@@ -32,33 +32,66 @@ public class EntitySectionStorage<T extends EntityAccess> {
         this.intialSectionVisibility = chunkStatusDiscriminator;
     }
 
+    // JettPack start - lithium: entity.fast_retrieval
     public void forEachAccessibleNonEmptySection(AABB box, Consumer<EntitySection<T>> action) {
-        int i = SectionPos.posToSectionCoord(box.minX - 2.0D);
-        int j = SectionPos.posToSectionCoord(box.minY - 2.0D);
-        int k = SectionPos.posToSectionCoord(box.minZ - 2.0D);
-        int l = SectionPos.posToSectionCoord(box.maxX + 2.0D);
-        int m = SectionPos.posToSectionCoord(box.maxY + 2.0D);
-        int n = SectionPos.posToSectionCoord(box.maxZ + 2.0D);
-
-        for(int o = i; o <= l; ++o) {
-            long p = SectionPos.asLong(o, 0, 0);
-            long q = SectionPos.asLong(o, -1, -1);
-            LongIterator longIterator = this.sectionIds.subSet(p, q + 1L).iterator();
-
-            while(longIterator.hasNext()) {
-                long r = longIterator.nextLong();
-                int s = SectionPos.y(r);
-                int t = SectionPos.z(r);
-                if (s >= j && s <= m && t >= k && t <= n) {
-                    EntitySection<T> entitySection = this.sections.get(r);
-                    if (entitySection != null && !entitySection.isEmpty() && entitySection.getStatus().isAccessible()) {
-                        action.accept(entitySection);
+        int minX = SectionPos.posToSectionCoord(box.minX - 2.0D);
+        int minY = SectionPos.posToSectionCoord(box.minY - 2.0D);
+        int minZ = SectionPos.posToSectionCoord(box.minZ - 2.0D);
+        int maxX = SectionPos.posToSectionCoord(box.maxX + 2.0D);
+        int maxY = SectionPos.posToSectionCoord(box.maxY + 2.0D);
+        int maxZ = SectionPos.posToSectionCoord(box.maxZ + 2.0D);
+
+        if (maxX >= minX + 4 || maxZ >= minZ + 4) {
+            // [VanillaCopy]
+            for(int o = minX; o <= maxX; ++o) {
+                long p = SectionPos.asLong(o, 0, 0);
+                long q = SectionPos.asLong(o, -1, -1);
+                LongIterator longIterator = this.sectionIds.subSet(p, q + 1L).iterator();
+
+                while(longIterator.hasNext()) {
+                    long r = longIterator.nextLong();
+                    int s = SectionPos.y(r);
+                    int t = SectionPos.z(r);
+                    if (s >= minY && s <= maxY && t >= minZ && t <= maxZ) {
+                        EntitySection<T> entitySection = this.sections.get(r);
+                        if (entitySection != null && !entitySection.isEmpty() && entitySection.getStatus().isAccessible()) {
+                            action.accept(entitySection);
+                        }
                     }
                 }
             }
+        } else {
+            for (int x = minX; x <= maxX; x++) {
+                for (int z = Math.max(minZ, 0); z <= maxZ; z++) {
+                    this.forEachInColumn(x, minY, maxY, z, action);
+                }
+
+                int bound = Math.min(-1, maxZ);
+                for (int z = minZ; z <= bound; z++) {
+                    this.forEachInColumn(x, minY, maxY, z, action);
+                }
+            }
         }
+    }
 
+    private void forEachInColumn(int x, int minY, int maxY, int z, Consumer<EntitySection<T>> action) {
+        //y from negative to positive, but y is treated as unsigned
+        for (int y = Math.max(minY, 0); y <= maxY; y++) {
+            this.consumeSection(SectionPos.asLong(x, y, z), action);
+        }
+        int bound = Math.min(-1, maxY);
+        for (int y = minY; y <= bound; y++) {
+            this.consumeSection(SectionPos.asLong(x, y, z), action);
+        }
+    }
+
+    private void consumeSection(long pos, Consumer<EntitySection<T>> action) {
+        EntitySection<T> section = this.getSection(pos);
+        if (section != null && 0 != section.size() && section.getStatus().isAccessible()) {
+            action.accept(section);
+        }
     }
+    // JettPack end
 
     public LongStream getExistingSectionPositionsInChunk(long chunkPos) {
         int i = ChunkPos.getX(chunkPos);
diff --git a/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java b/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
index 765b56776e457109ddea9f7dbfd0b17beefee51e..3a83c357f1a244f61c429ad5c34e3aed7b80449f 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
@@ -11,14 +11,35 @@ public final class ImprovedNoise {
     public final double yo;
     public final double zo;
 
+    // JettPack start - C2ME math optimizations
+    private static final double[][] SIMPLEX_NOISE_GRADIENTS = new double[][]{
+            {1, 1, 0},
+            {-1, 1, 0},
+            {1, -1, 0},
+            {-1, -1, 0},
+            {1, 0, 1},
+            {-1, 0, 1},
+            {1, 0, -1},
+            {-1, 0, -1},
+            {0, 1, 1},
+            {0, -1, 1},
+            {0, 1, -1},
+            {0, -1, -1},
+            {1, 1, 0},
+            {0, -1, 1},
+            {-1, 1, 0},
+            {0, -1, -1}
+    };
+    // JettPack end
+
     public ImprovedNoise(RandomSource random) {
         this.xo = random.nextDouble() * 256.0D;
         this.yo = random.nextDouble() * 256.0D;
         this.zo = random.nextDouble() * 256.0D;
-        this.p = new byte[256];
+        this.p = new byte[256]; // JettPack - rename
 
         for(int i = 0; i < 256; ++i) {
-            this.p[i] = (byte)i;
+            this.p[i] = (byte)i; // JettPack
         }
 
         for(int j = 0; j < 256; ++j) {
@@ -34,34 +55,38 @@ public final class ImprovedNoise {
         return this.noise(x, y, z, 0.0D, 0.0D);
     }
 
+    // JettPack start - C2ME math optimizations
+    /**
+     * @author ishland
+     * @reason optimize: remove frequent type conversions
+     */
     /** @deprecated */
     @Deprecated
     public double noise(double x, double y, double z, double yScale, double yMax) {
         double d = x + this.xo;
         double e = y + this.yo;
         double f = z + this.zo;
-        int i = Mth.floor(d);
-        int j = Mth.floor(e);
-        int k = Mth.floor(f);
-        double g = d - (double)i;
-        double h = e - (double)j;
-        double l = f - (double)k;
-        double o;
-        if (yScale != 0.0D) {
+        double i = Mth.floor(d);
+        double j = Mth.floor(e);
+        double k = Mth.floor(f);
+        double g = d - i;
+        double h = e - j;
+        double l = f - k;
+        double o = 0.0D;
+        if (yScale != 0.0) {
             double m;
-            if (yMax >= 0.0D && yMax < h) {
+            if (yMax >= 0.0 && yMax < h) {
                 m = yMax;
             } else {
                 m = h;
             }
 
-            o = (double)Mth.floor(m / yScale + (double)1.0E-7F) * yScale;
-        } else {
-            o = 0.0D;
+            o = Mth.floor(m / yScale + 1.0E-7F) * yScale;
         }
 
-        return this.sampleAndLerp(i, j, k, g, h - o, l, h);
+        return this.sampleAndLerp((int) i, (int) j, (int) k, g, h - o, l, h);
     }
+    // JettPack end
 
     public double noiseWithDerivative(double x, double y, double z, double[] ds) {
         double d = x + this.xo;
@@ -84,26 +109,140 @@ public final class ImprovedNoise {
         return this.p[hash & 255] & 255;
     }
 
+    // JettPack start - C2ME math optimizations
+    /**
+     * @author ishland
+     * @reason inline math & small optimization: remove frequent type conversions and redundant ops
+     */
     private double sampleAndLerp(int sectionX, int sectionY, int sectionZ, double localX, double localY, double localZ, double fadeLocalX) {
-        int i = this.p(sectionX);
-        int j = this.p(sectionX + 1);
-        int k = this.p(i + sectionY);
-        int l = this.p(i + sectionY + 1);
-        int m = this.p(j + sectionY);
-        int n = this.p(j + sectionY + 1);
-        double d = gradDot(this.p(k + sectionZ), localX, localY, localZ);
-        double e = gradDot(this.p(m + sectionZ), localX - 1.0D, localY, localZ);
-        double f = gradDot(this.p(l + sectionZ), localX, localY - 1.0D, localZ);
-        double g = gradDot(this.p(n + sectionZ), localX - 1.0D, localY - 1.0D, localZ);
-        double h = gradDot(this.p(k + sectionZ + 1), localX, localY, localZ - 1.0D);
-        double o = gradDot(this.p(m + sectionZ + 1), localX - 1.0D, localY, localZ - 1.0D);
-        double p = gradDot(this.p(l + sectionZ + 1), localX, localY - 1.0D, localZ - 1.0D);
-        double q = gradDot(this.p(n + sectionZ + 1), localX - 1.0D, localY - 1.0D, localZ - 1.0D);
-        double r = Mth.smoothstep(localX);
-        double s = Mth.smoothstep(fadeLocalX);
-        double t = Mth.smoothstep(localZ);
-        return Mth.lerp3(r, s, t, d, e, f, g, h, o, p, q);
+        final int var0 = sectionX & 0xFF;
+        final int var1 = (sectionX + 1) & 0xFF;
+        final int var2 = this.p[var0] & 0xFF;
+        final int var3 = this.p[var1] & 0xFF;
+        final int var4 = (var2 + sectionY) & 0xFF;
+        final int var5 = (var2 + sectionY + 1) & 0xFF;
+        final int var6 = (var3 + sectionY) & 0xFF;
+        final int var7 = (var3 + sectionY + 1) & 0xFF;
+        final int var8 = this.p[var4] & 0xFF;
+        final int var9 = this.p[var5] & 0xFF;
+        final int var10 = this.p[var6] & 0xFF;
+        final int var11 = this.p[var7] & 0xFF;
+
+        final int var12 = (var8 + sectionZ) & 0xFF;
+        final int var13 = (var10 + sectionZ) & 0xFF;
+        final int var14 = (var9 + sectionZ) & 0xFF;
+        final int var15 = (var11 + sectionZ) & 0xFF;
+        final int var16 = (var8 + sectionZ + 1) & 0xFF;
+        final int var17 = (var10 + sectionZ + 1) & 0xFF;
+        final int var18 = (var9 + sectionZ + 1) & 0xFF;
+        final int var19 = (var11 + sectionZ + 1) & 0xFF;
+        final int var20 = this.p[var12] & 15;
+        final int var21 = this.p[var13] & 15;
+        final int var22 = this.p[var14] & 15;
+        final int var23 = this.p[var15] & 15;
+        final int var24 = this.p[var16] & 15;
+        final int var25 = this.p[var17] & 15;
+        final int var26 = this.p[var18] & 15;
+        final int var27 = this.p[var19] & 15;
+        final double[] var28 = SIMPLEX_NOISE_GRADIENTS[var20];
+        final double[] var29 = SIMPLEX_NOISE_GRADIENTS[var21];
+        final double[] var30 = SIMPLEX_NOISE_GRADIENTS[var22];
+        final double[] var31 = SIMPLEX_NOISE_GRADIENTS[var23];
+        final double[] var32 = SIMPLEX_NOISE_GRADIENTS[var24];
+        final double[] var33 = SIMPLEX_NOISE_GRADIENTS[var25];
+        final double[] var34 = SIMPLEX_NOISE_GRADIENTS[var26];
+        final double[] var35 = SIMPLEX_NOISE_GRADIENTS[var27];
+        final double var36 = var28[0];
+        final double var37 = var28[1];
+        final double var38 = var28[2];
+        final double var39 = var29[0];
+        final double var40 = var29[1];
+        final double var41 = var29[2];
+        final double var42 = var30[0];
+        final double var43 = var30[1];
+        final double var44 = var30[2];
+        final double var45 = var31[0];
+        final double var46 = var31[1];
+        final double var47 = var31[2];
+        final double var48 = var32[0];
+        final double var49 = var32[1];
+        final double var50 = var32[2];
+        final double var51 = var33[0];
+        final double var52 = var33[1];
+        final double var53 = var33[2];
+        final double var54 = var34[0];
+        final double var55 = var34[1];
+        final double var56 = var34[2];
+        final double var57 = var35[0];
+        final double var58 = var35[1];
+        final double var59 = var35[2];
+        final double var60 = localX - 1.0;
+        final double var61 = localY - 1.0;
+        final double var62 = localZ - 1.0;
+        final double var63 = var36 * localX;
+        final double var64 = var37 * localY;
+        final double var65 = var38 * localZ;
+        final double var66 = var39 * var60;
+        final double var67 = var40 * localY;
+        final double var68 = var41 * localZ;
+        final double var69 = var42 * localX;
+        final double var70 = var43 * var61;
+        final double var71 = var44 * localZ;
+        final double var72 = var45 * var60;
+        final double var73 = var46 * var61;
+        final double var74 = var47 * localZ;
+        final double var75 = var48 * localX;
+        final double var76 = var49 * localY;
+        final double var77 = var50 * var62;
+        final double var78 = var51 * var60;
+        final double var79 = var52 * localY;
+        final double var80 = var53 * var62;
+        final double var81 = var54 * localX;
+        final double var82 = var55 * var61;
+        final double var83 = var56 * var62;
+        final double var84 = var57 * var60;
+        final double var85 = var58 * var61;
+        final double var86 = var59 * var62;
+        final double var87 = var63 + var64 + var65;
+        final double var88 = var66 + var67 + var68;
+        final double var89 = var69 + var70 + var71;
+        final double var90 = var72 + var73 + var74;
+        final double var91 = var75 + var76 + var77;
+        final double var92 = var78 + var79 + var80;
+        final double var93 = var81 + var82 + var83;
+        final double var94 = var84 + var85 + var86;
+
+        final double var95 = localX * 6.0 - 15.0;
+        final double var96 = fadeLocalX * 6.0 - 15.0;
+        final double var97 = localZ * 6.0 - 15.0;
+        final double var98 = localX * var95 + 10.0;
+        final double var99 = fadeLocalX * var96 + 10.0;
+        final double var100 = localZ * var97 + 10.0;
+        final double var101 = localX * localX * localX * var98;
+        final double var102 = fadeLocalX * fadeLocalX * fadeLocalX * var99;
+        final double var103 = localZ * localZ * localZ * var100;
+
+        final double var104 = var90 - var89;
+        final double var105 = var88 - var87;
+        final double var106 = var94 - var93;
+        final double var107 = var92 - var91;
+        final double var108 = var101 * var104;
+        final double var109 = var101 * var105;
+        final double var110 = var101 * var106;
+        final double var111 = var101 * var107;
+        final double var112 = var89 + var108;
+        final double var113 = var87 + var109;
+        final double var114 = var93 + var110;
+        final double var115 = var91 + var111;
+        final double var116 = var112 - var113;
+        final double var117 = var114 - var115;
+        final double var118 = var102 * var116;
+        final double var119 = var102 * var117;
+        final double var120 = var113 + var118;
+        final double var121 = var115 + var119;
+        return var120 + (var103 * (var121 - var120));
     }
+    // JettPack end
 
     private double sampleWithDerivative(int sectionX, int sectionY, int sectionZ, double localX, double localY, double localZ, double[] ds) {
         int i = this.p(sectionX);
diff --git a/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java b/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
index 1966b9588c9f77874a5f9f33cb9350ade7547ee7..e7ac692e98ca5311a1010474d7cb6598e1605166 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
@@ -190,9 +190,15 @@ public class PerlinNoise {
         return this.noiseLevels[this.noiseLevels.length - 1 - octave];
     }
 
+    // JettPack start - C2ME math optimizations
+    /**
+     * @author ishland
+     * @reason remove frequent type conversion
+     */
     public static double wrap(double value) {
-        return value - (double)Mth.lfloor(value / 3.3554432E7D + 0.5D) * 3.3554432E7D;
+        return value - Mth.lfloor(value / 3.3554432E7 + 0.5) * 3.3554432E7;
     }
+    // JettPack end
 
     protected int firstOctave() {
         return this.firstOctave;
diff --git a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
index 601f8099f74e81c17600566b3c9b7a6dd39c9bcb..e71aa663c1f895748d3718980f1bea6248a1f1fa 100644
--- a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
+++ b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
@@ -24,6 +24,7 @@ public class PlayerDataStorage {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final File playerDir;
     protected final DataFixer fixerUpper;
+    private final me.titaniumtown.cache.NBTCache dataCache = new me.titaniumtown.cache.NBTCache(); // JettPack - NBT Cache system
 
     public PlayerDataStorage(LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer) {
         this.fixerUpper = dataFixer;
@@ -37,11 +38,23 @@ public class PlayerDataStorage {
             CompoundTag nbttagcompound = player.saveWithoutId(new CompoundTag());
             File file = File.createTempFile(player.getStringUUID() + "-", ".dat", this.playerDir);
 
-            NbtIo.writeCompressed(nbttagcompound, file);
-            File file1 = new File(this.playerDir, player.getStringUUID() + ".dat");
-            File file2 = new File(this.playerDir, player.getStringUUID() + ".dat_old");
+            // JettPack start - NBT Cache system
+            Runnable task = () -> {
+                try {
+                    NbtIo.writeCompressed(nbttagcompound, file);
+                    File file1 = new File(this.playerDir, player.getStringUUID() + ".dat");
+                    File file2 = new File(this.playerDir, player.getStringUUID() + ".dat_old");
 
-            Util.safeReplaceFile(file1, file, file2);
+                    Util.safeReplaceFile(file1, file, file2);
+                } catch (Exception exception) {
+                    PlayerDataStorage.LOGGER.error("Failed to save player data for {}", player.getScoreboardName(), exception); // Paper
+                }
+                };
+            synchronized (this.dataCache){
+                this.dataCache.put(file, nbttagcompound);
+            }
+            net.minecraft.server.MCUtil.asyncExecutor.execute(task);
+            // JettPack end
         } catch (Exception exception) {
             PlayerDataStorage.LOGGER.warn("Failed to save player data for {}", player.getScoreboardName(), exception); // Paper
         }
@@ -56,9 +69,18 @@ public class PlayerDataStorage {
             File file = new File(this.playerDir, player.getStringUUID() + ".dat");
             // Spigot Start
             boolean usingWrongFile = false;
-            if ( org.bukkit.Bukkit.getOnlineMode() && !file.exists() ) // Paper - Check online mode first
+            // JettPack start - NBT Cache system
+            boolean normalFile = file.exists() && file.isFile();
+            CompoundTag playerData;
+            synchronized (this.dataCache){
+                playerData = this.dataCache.get(file);
+            }
+            if (playerData == null && org.bukkit.Bukkit.getOnlineMode() && !normalFile ) // Paper - Check online mode first
             {
                 file = new File( this.playerDir, java.util.UUID.nameUUIDFromBytes( ( "OfflinePlayer:" + player.getScoreboardName() ).getBytes( "UTF-8" ) ).toString() + ".dat");
+                synchronized (this.dataCache){
+                    playerData = this.dataCache.get(file);
+                }
                 if ( file.exists() )
                 {
                     usingWrongFile = true;
@@ -67,9 +89,13 @@ public class PlayerDataStorage {
             }
             // Spigot End
 
-            if (file.exists() && file.isFile()) {
+            if (playerData != null) {
+                nbttagcompound = playerData;
+            } else if (normalFile) {
+
                 nbttagcompound = NbtIo.readCompressed(file);
             }
+            // JettPack end
             // Spigot Start
             if ( usingWrongFile )
             {
diff --git a/src/main/java/net/minecraft/world/phys/AABB.java b/src/main/java/net/minecraft/world/phys/AABB.java
index 68cc6f2a78a06293a29317fda72ab3ee79b3533a..dfbc871cd3474346b8d83f0b55b4f5f9665e4386 100644
--- a/src/main/java/net/minecraft/world/phys/AABB.java
+++ b/src/main/java/net/minecraft/world/phys/AABB.java
@@ -6,6 +6,7 @@ import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.util.Mth;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
+import net.minecraft.core.Direction; // JettPack
 
 public class AABB {
     private static final double EPSILON = 1.0E-7D;
@@ -16,6 +17,15 @@ public class AABB {
     public final double maxY;
     public final double maxZ;
 
+    // JettPack start - lithium: fast_util
+    static {
+        assert Direction.Axis.X.ordinal() == 0;
+        assert Direction.Axis.Y.ordinal() == 1;
+        assert Direction.Axis.Z.ordinal() == 2;
+        assert Direction.Axis.values().length == 3;
+    }
+    // JettPack end
+
     public AABB(double x1, double y1, double z1, double x2, double y2, double z2) {
         this.minX = Math.min(x1, x2);
         this.minY = Math.min(y1, y2);
@@ -81,11 +91,33 @@ public class AABB {
     }
 
     public double min(Direction.Axis axis) {
-        return axis.choose(this.minX, this.minY, this.minZ);
+        // JettPack start - lithium: fast_util
+        switch (axis.ordinal()) {
+            case 0: //X
+                return this.minX;
+            case 1: //Y
+                return this.minY;
+            case 2: //Z
+                return this.minZ;
+        }
+
+        throw new IllegalArgumentException();
+        // JettPack end
     }
 
     public double max(Direction.Axis axis) {
-        return axis.choose(this.maxX, this.maxY, this.maxZ);
+        // JettPack start - lithium: fast_util
+        switch (axis.ordinal()) {
+            case 0: //X
+                return this.maxX;
+            case 1: //Y
+                return this.maxY;
+            case 2: //Z
+                return this.maxZ;
+        }
+
+        throw new IllegalArgumentException();
+        // JettPack end
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java b/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
index a544db042c8d2ecec8d323770552c4f10ca758a6..c04da8da5b40430b61972bce32cec4e8c0370bac 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
@@ -4,6 +4,7 @@ import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
 
 public class CubePointRange extends AbstractDoubleList {
     private final int parts;
+    private double scale; // JettPack - lithium: shapes.precompute_shape_arrays
 
     CubePointRange(int sectionCount) {
         if (sectionCount <= 0) {
@@ -11,10 +12,11 @@ public class CubePointRange extends AbstractDoubleList {
         } else {
             this.parts = sectionCount;
         }
+        this.scale = 1.0D / sectionCount; // JettPack - lithium: shapes.precompute_shape_arrays
     }
 
     public double getDouble(int i) {
-        return (double)i / (double)this.parts;
+        return i * this.scale; // JettPack - lithium: shapes.precompute_shape_arrays
     }
 
     public int size() {
diff --git a/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java b/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
index 68e89dbd79171627046e89699057964e44c40e7d..959588962acb0196ec9f1cc2502e62117f6ccdc4 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
@@ -3,15 +3,25 @@ package net.minecraft.world.phys.shapes;
 import it.unimi.dsi.fastutil.doubles.DoubleList;
 import net.minecraft.core.Direction;
 import net.minecraft.util.Mth;
+import net.minecraft.world.phys.shapes.CubePointRange; // JettPack
 
 public final class CubeVoxelShape extends VoxelShape {
+    private DoubleList[] list; // JettPack - lithium: shapes.precompute_shape_arrays
+
     protected CubeVoxelShape(DiscreteVoxelShape voxels) {
         super(voxels);
+        // JettPack start - lithium: shapes.precompute_shape_arrays
+        this.list = new DoubleList[Direction.VALUES.length];
+
+        for (Direction.Axis axis : Direction.Axis.VALUES) {
+            this.list[axis.ordinal()] = new CubePointRange(voxels.getSize(axis));
+        }
+        // JettPack end
     }
 
     @Override
     protected DoubleList getCoords(Direction.Axis axis) {
-        return new CubePointRange(this.shape.getSize(axis));
+        return this.list[axis.ordinal()]; // JettPack - lithium: shapes.precompute_shape_arrays
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index acd57ba592e7331a0b3271b2df67b67ced2e9ef3..73215ce87dfc4ece97e0e3e80181fd6ff46c597e 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -955,6 +955,7 @@ public final class CraftServer implements Server {
 
         org.spigotmc.SpigotConfig.init((File) console.options.valueOf("spigot-settings")); // Spigot
         com.destroystokyo.paper.PaperConfig.init((File) console.options.valueOf("paper-settings")); // Paper
+        me.titaniumtown.JettPackConfig.init((File) console.options.valueOf("jettpack-settings")); // JettPack
         for (ServerLevel world : this.console.getAllLevels()) {
             // world.serverLevelData.setDifficulty(config.difficulty); // Paper - per level difficulty
             world.setSpawnSettings(world.serverLevelData.getDifficulty() != Difficulty.PEACEFUL && config.spawnMonsters, config.spawnAnimals); // Paper - per level difficulty (from MinecraftServer#setDifficulty(ServerLevel, Difficulty, boolean))
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index fbe68bd4739d9a0e7d9bc4c3d5ba8ecfd2d13954..268f90f5ba27a89f15691d6b083d8dbb414926a3 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -153,6 +153,14 @@ public class Main {
                         .describedAs("Jar file");
                 // Paper end
 
+                // JettPack start
+                acceptsAll(asList("jettpack", "jettpack-settings"), "File for jettpack settings")
+                        .withRequiredArg()
+                        .ofType(File.class)
+                        .defaultsTo(new File("jettpack.yml"))
+                        .describedAs("Yml file");
+                // JettPack end
+
                 // Paper start
                 acceptsAll(asList("server-name"), "Name of the server")
                         .withRequiredArg()
